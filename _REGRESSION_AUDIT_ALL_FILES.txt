
================================================================================
FILE: tests/integration/test_f1_end_to_end.py
================================================================================
     1	# SPDX-License-Identifier: MIT
     2	"""End-to-end integration tests for Family F1 (Single-Ended Via Transition).
     3	
     4	This module tests the complete F1 coupon generation pipeline:
     5	    spec -> resolve -> LayoutPlan -> BoardWriter -> .kicad_pcb
     6	
     7	F1 coupons are via transition structures:
     8	    end-launch -> CPWG -> via transition -> CPWG -> end-launch
     9	
    10	These tests verify:
    11	1. F1 specs load and validate correctly
    12	2. LayoutPlan computes correct geometry (left/right segments, discontinuity)
    13	3. BoardWriter generates valid KiCad board file with vias, antipads, cutouts
    14	4. Generated board is deterministic (same spec -> same output)
    15	5. Return vias and antipads are correctly placed
    16	6. All golden specs produce valid boards
    17	
    18	Satisfies REQ-M1-007.
    19	"""
    20	
    21	from __future__ import annotations
    22	
    23	import json
    24	from pathlib import Path
    25	from typing import Any
    26	
    27	import pytest
    28	import yaml
    29	
    30	from formula_foundry.coupongen.api import (
    31	    generate_kicad,
    32	    load_spec,
    33	    resolve_spec,
    34	)
    35	from formula_foundry.coupongen.builders.f1_builder import (
    36	    F1CouponComposition,
    37	    build_f1_coupon,
    38	)
    39	from formula_foundry.coupongen.families import FAMILY_F1
    40	from formula_foundry.coupongen.geom.layout import LayoutPlan
    41	from formula_foundry.coupongen.kicad import (
    42	    build_board_text,
    43	    parse,
    44	    write_board,
    45	)
    46	from formula_foundry.coupongen.kicad.board_writer import BoardWriter
    47	from formula_foundry.coupongen.resolve import resolve
    48	from formula_foundry.coupongen.spec import CouponSpec
    49	
    50	# Test data directory
    51	REPO_ROOT = Path(__file__).resolve().parents[2]
    52	GOLDEN_SPECS_DIR = REPO_ROOT / "tests" / "golden_specs"
    53	
    54	
    55	def _minimal_f1_spec_data() -> dict[str, Any]:
    56	    """Create minimal valid F1 spec data with via transition."""
    57	    return {
    58	        "schema_version": 1,
    59	        "coupon_family": FAMILY_F1,
    60	        "units": "nm",
    61	        "toolchain": {
    62	            "kicad": {
    63	                "version": "9.0.7",
    64	                "docker_image": "kicad/kicad:9.0.7@sha256:0000000000000000000000000000000000000000000000000000000000000001",
    65	            }
    66	        },
    67	        "fab_profile": {"id": "oshpark_4layer", "overrides": {}},
    68	        "stackup": {
    69	            "copper_layers": 4,
    70	            "thicknesses_nm": {
    71	                "L1_to_L2": 180000,
    72	                "L2_to_L3": 800000,
    73	                "L3_to_L4": 180000,
    74	            },
    75	            "materials": {"er": 4.1, "loss_tangent": 0.02},
    76	        },
    77	        "board": {
    78	            "outline": {
    79	                "width_nm": 20000000,
    80	                "length_nm": 80000000,
    81	                "corner_radius_nm": 2000000,
    82	            },
    83	            "origin": {"mode": "EDGE_L_CENTER"},
    84	            "text": {"coupon_id": "F1-TEST-001", "include_manifest_hash": True},
    85	        },
    86	        "connectors": {
    87	            "left": {
    88	                "footprint": "Coupongen_Connectors:SMA_EndLaunch_Generic",
    89	                "position_nm": [5000000, 0],
    90	                "rotation_deg": 180,
    91	            },
    92	            "right": {
    93	                "footprint": "Coupongen_Connectors:SMA_EndLaunch_Generic",
    94	                "position_nm": [75000000, 0],
    95	                "rotation_deg": 0,
    96	            },
    97	        },
    98	        "transmission_line": {
    99	            "type": "CPWG",
   100	            "layer": "F.Cu",
   101	            "w_nm": 300000,
   102	            "gap_nm": 180000,
   103	            "length_left_nm": 25000000,
   104	            # length_right_nm is derived from continuity formula for F1
   105	        },
   106	        "discontinuity": {
   107	            "type": "VIA_TRANSITION",
   108	            "signal_via": {
   109	                "drill_nm": 300000,
   110	                "diameter_nm": 650000,
   111	                "pad_diameter_nm": 900000,
   112	            },
   113	            "antipads": {
   114	                "In1.Cu": {
   115	                    "shape": "ROUNDRECT",
   116	                    "rx_nm": 1200000,
   117	                    "ry_nm": 900000,
   118	                    "corner_nm": 250000,
   119	                },
   120	                "In2.Cu": {
   121	                    "shape": "CIRCLE",
   122	                    "r_nm": 1100000,
   123	                },
   124	            },
   125	            "return_vias": {
   126	                "pattern": "RING",
   127	                "count": 4,
   128	                "radius_nm": 1700000,
   129	                "via": {"drill_nm": 300000, "diameter_nm": 650000},
   130	            },
   131	            "plane_cutouts": {
   132	                "In1.Cu": {
   133	                    "shape": "SLOT",
   134	                    "length_nm": 3000000,
   135	                    "width_nm": 1500000,
   136	                    "rotation_deg": 0,
   137	                },
   138	            },
   139	        },
   140	        "constraints": {
   141	            "mode": "REJECT",
   142	            "drc": {"must_pass": True, "severity": "all"},
   143	            "symmetry": {"enforce": True},
   144	            "allow_unconnected_copper": False,
   145	        },
   146	        "export": {
   147	            "gerbers": {"enabled": True, "format": "gerbers"},
   148	            "drill": {"enabled": True, "format": "excellon"},
   149	            "outputs_dir": "artifacts/",
   150	        },
   151	    }
   152	
   153	
   154	def _minimal_f1_spec_data_no_return_vias() -> dict[str, Any]:
   155	    """Create F1 spec data without return vias."""
   156	    data = _minimal_f1_spec_data()
   157	    data["discontinuity"]["return_vias"] = None
   158	    data["discontinuity"]["antipads"] = {}
   159	    data["discontinuity"]["plane_cutouts"] = {}
   160	    return data
   161	
   162	
   163	@pytest.fixture
   164	def f1_spec() -> CouponSpec:
   165	    """Create a validated F1 CouponSpec."""
   166	    return CouponSpec.model_validate(_minimal_f1_spec_data())
   167	
   168	
   169	@pytest.fixture
   170	def f1_spec_minimal() -> CouponSpec:
   171	    """Create a validated F1 CouponSpec without optional features."""
   172	    return CouponSpec.model_validate(_minimal_f1_spec_data_no_return_vias())
   173	
   174	
   175	def _collect_f1_golden_specs() -> list[Path]:
   176	    """Collect all F1 golden spec files."""
   177	    return sorted(GOLDEN_SPECS_DIR.glob("f1_via_*.yaml"))
   178	
   179	
   180	class TestF1SpecValidation:
   181	    """Tests for F1 spec loading and validation."""
   182	
   183	    def test_f1_spec_loads_successfully(self, f1_spec: CouponSpec) -> None:
   184	        """F1 spec should load and validate successfully."""
   185	        assert f1_spec.coupon_family == FAMILY_F1
   186	        assert f1_spec.discontinuity is not None
   187	
   188	    def test_f1_spec_has_required_fields(self, f1_spec: CouponSpec) -> None:
   189	        """F1 spec should have all required fields."""
   190	        assert f1_spec.schema_version == 1
   191	        assert f1_spec.board is not None
   192	        assert f1_spec.connectors is not None
   193	        assert f1_spec.transmission_line is not None
   194	        assert f1_spec.constraints is not None
   195	        assert f1_spec.discontinuity is not None
   196	
   197	    def test_f1_spec_discontinuity_type(self, f1_spec: CouponSpec) -> None:
   198	        """F1 spec discontinuity should be VIA_TRANSITION."""
   199	        assert f1_spec.discontinuity is not None
   200	        assert f1_spec.discontinuity.type == "VIA_TRANSITION"
   201	
   202	    def test_f1_spec_connectors_configured(self, f1_spec: CouponSpec) -> None:
   203	        """F1 spec should have left and right connectors."""
   204	        assert f1_spec.connectors.left is not None
   205	        assert f1_spec.connectors.right is not None
   206	        assert f1_spec.connectors.left.footprint == "Coupongen_Connectors:SMA_EndLaunch_Generic"
   207	        assert f1_spec.connectors.right.footprint == "Coupongen_Connectors:SMA_EndLaunch_Generic"
   208	
   209	    def test_f1_spec_has_signal_via(self, f1_spec: CouponSpec) -> None:
   210	        """F1 spec should have signal via parameters."""
   211	        assert f1_spec.discontinuity is not None
   212	        sig_via = f1_spec.discontinuity.signal_via
   213	        assert sig_via.drill_nm == 300000
   214	        assert sig_via.diameter_nm == 650000
   215	        assert sig_via.pad_diameter_nm == 900000
   216	
   217	    def test_f1_spec_has_return_vias(self, f1_spec: CouponSpec) -> None:
   218	        """F1 spec should have return vias configured."""
   219	        assert f1_spec.discontinuity is not None
   220	        ret_vias = f1_spec.discontinuity.return_vias
   221	        assert ret_vias is not None
   222	        assert ret_vias.pattern == "RING"
   223	        assert ret_vias.count == 4
   224	        assert ret_vias.radius_nm == 1700000
   225	
   226	    def test_f1_spec_has_antipads(self, f1_spec: CouponSpec) -> None:
   227	        """F1 spec should have antipads on internal layers."""
   228	        assert f1_spec.discontinuity is not None
   229	        antipads = f1_spec.discontinuity.antipads
   230	        assert "In1.Cu" in antipads
   231	        assert "In2.Cu" in antipads
   232	
   233	
   234	class TestF1Resolver:
   235	    """Tests for F1 spec resolution to ResolvedDesign."""
   236	
   237	    def test_f1_resolves_to_design(self, f1_spec: CouponSpec) -> None:
   238	        """F1 spec should resolve to a ResolvedDesign."""
   239	        resolved = resolve(f1_spec)
   240	        assert resolved is not None
   241	        assert resolved.coupon_family == FAMILY_F1
   242	
   243	    def test_f1_resolved_has_layout_plan(self, f1_spec: CouponSpec) -> None:
   244	        """Resolved F1 design should have a LayoutPlan attached."""
   245	        resolved = resolve(f1_spec)
   246	        assert resolved.layout_plan is not None
   247	        assert isinstance(resolved.layout_plan, LayoutPlan)
   248	
   249	    def test_f1_layout_plan_has_discontinuity(self, f1_spec: CouponSpec) -> None:
   250	        """F1 LayoutPlan should have a discontinuity (x_disc_nm is not None)."""
   251	        resolved = resolve(f1_spec)
   252	        layout = resolved.layout_plan
   253	        assert layout is not None
   254	        assert layout.x_disc_nm is not None
   255	        assert layout.has_discontinuity
   256	
   257	    def test_f1_layout_plan_has_two_segments(self, f1_spec: CouponSpec) -> None:
   258	        """F1 LayoutPlan should have two segments (left and right)."""
   259	        resolved = resolve(f1_spec)
   260	        layout = resolved.layout_plan
   261	        assert layout is not None
   262	        assert len(layout.segments) == 2
   263	
   264	        labels = {seg.label for seg in layout.segments}
   265	        assert "left" in labels
   266	        assert "right" in labels
   267	
   268	    def test_f1_layout_plan_segments_meet_at_discontinuity(self, f1_spec: CouponSpec) -> None:
   269	        """F1 segments should meet at the discontinuity center."""
   270	        resolved = resolve(f1_spec)
   271	        layout = resolved.layout_plan
   272	        assert layout is not None
   273	        assert layout.x_disc_nm is not None
   274	
   275	        left_seg = layout.get_segment_by_label("left")
   276	        right_seg = layout.get_segment_by_label("right")
   277	        assert left_seg is not None
   278	        assert right_seg is not None
   279	
   280	        # Left segment ends at discontinuity
   281	        assert left_seg.x_end_nm == layout.x_disc_nm
   282	        # Right segment starts at discontinuity
   283	        assert right_seg.x_start_nm == layout.x_disc_nm
   284	
   285	    def test_f1_layout_plan_derived_right_length(self, f1_spec: CouponSpec) -> None:
   286	        """F1 right length should be derived from continuity formula."""
   287	        resolved = resolve(f1_spec)
   288	        assert resolved.length_right_nm is not None
   289	
   290	        # Verify continuity: left_x + left_length + right_length = right_x
   291	        layout = resolved.layout_plan
   292	        assert layout is not None
   293	        left_pad_x = layout.left_port.signal_pad_x_nm
   294	        right_pad_x = layout.right_port.signal_pad_x_nm
   295	        left_length = f1_spec.transmission_line.length_left_nm
   296	
   297	        # Derived right length = right_pad_x - (left_pad_x + left_length)
   298	        derived_right = right_pad_x - (left_pad_x + left_length)
   299	        assert resolved.length_right_nm == derived_right
   300	
   301	
   302	class TestF1Builder:
   303	    """Tests for F1 builder composition."""
   304	
   305	    def test_f1_builder_creates_composition(self, f1_spec: CouponSpec) -> None:
   306	        """F1 builder should create an F1CouponComposition."""
   307	        resolved = resolve(f1_spec)
   308	        composition = build_f1_coupon(f1_spec, resolved)
   309	        assert isinstance(composition, F1CouponComposition)
   310	
   311	    def test_f1_composition_has_all_features(self, f1_spec: CouponSpec) -> None:
   312	        """F1 composition should have all features."""
   313	        resolved = resolve(f1_spec)
   314	        composition = build_f1_coupon(f1_spec, resolved)
   315	
   316	        assert composition.board_outline is not None
   317	        assert composition.left_port is not None
   318	        assert composition.right_port is not None
   319	        assert composition.transmission_line is not None
   320	        assert composition.discontinuity is not None
   321	
   322	    def test_f1_composition_has_signal_via(self, f1_spec: CouponSpec) -> None:
   323	        """F1 composition should have signal via at discontinuity."""
   324	        resolved = resolve(f1_spec)
   325	        composition = build_f1_coupon(f1_spec, resolved)
   326	
   327	        via = composition.signal_via
   328	        assert via is not None
   329	        assert via.position == composition.discontinuity_position
   330	
   331	    def test_f1_composition_has_return_vias(self, f1_spec: CouponSpec) -> None:
   332	        """F1 composition should have return vias around signal via."""
   333	        resolved = resolve(f1_spec)
   334	        composition = build_f1_coupon(f1_spec, resolved)
   335	
   336	        return_vias = composition.return_vias
   337	        assert len(return_vias) == 4  # From spec
   338	
   339	    def test_f1_composition_has_antipads(self, f1_spec: CouponSpec) -> None:
   340	        """F1 composition should have antipad polygons."""
   341	        resolved = resolve(f1_spec)
   342	        composition = build_f1_coupon(f1_spec, resolved)
   343	
   344	        antipads = composition.all_antipads
   345	        assert len(antipads) == 2  # In1.Cu and In2.Cu
   346	
   347	    def test_f1_composition_has_cutouts(self, f1_spec: CouponSpec) -> None:
   348	        """F1 composition should have plane cutout polygons."""
   349	        resolved = resolve(f1_spec)
   350	        composition = build_f1_coupon(f1_spec, resolved)
   351	
   352	        cutouts = composition.all_cutouts
   353	        assert len(cutouts) == 1  # In1.Cu slot
   354	
   355	    def test_f1_composition_minimal_no_return_vias(self, f1_spec_minimal: CouponSpec) -> None:
   356	        """F1 minimal composition should work without return vias."""
   357	        resolved = resolve(f1_spec_minimal)
   358	        composition = build_f1_coupon(f1_spec_minimal, resolved)
   359	
   360	        assert composition.return_vias == ()
   361	        assert composition.all_antipads == ()
   362	        assert composition.all_cutouts == ()
   363	
   364	
   365	class TestF1BoardWriter:
   366	    """Tests for F1 board file generation."""
   367	
   368	    def test_f1_board_writer_creates_valid_board(self, f1_spec: CouponSpec) -> None:
   369	        """F1 BoardWriter should create a valid board S-expression."""
   370	        resolved = resolve(f1_spec)
   371	        writer = BoardWriter(f1_spec, resolved)
   372	        board = writer.build_board()
   373	
   374	        assert isinstance(board, list)
   375	        assert board[0] == "kicad_pcb"
   376	
   377	    def test_f1_board_has_two_track_segments(self, f1_spec: CouponSpec) -> None:
   378	        """F1 board should have two track segments (left and right)."""
   379	        resolved = resolve(f1_spec)
   380	        writer = BoardWriter(f1_spec, resolved)
   381	        board = writer.build_board()
   382	
   383	        segments = [e for e in board if isinstance(e, list) and e[0] == "segment"]
   384	        assert len(segments) == 2
   385	
   386	    def test_f1_board_has_signal_via(self, f1_spec: CouponSpec) -> None:
   387	        """F1 board should have a signal via at the discontinuity."""
   388	        resolved = resolve(f1_spec)
   389	        writer = BoardWriter(f1_spec, resolved)
   390	        board = writer.build_board()
   391	
   392	        vias = [e for e in board if isinstance(e, list) and e[0] == "via"]
   393	        # 1 signal via + 4 return vias = 5 total
   394	        assert len(vias) >= 1
   395	
   396	    def test_f1_board_has_return_vias(self, f1_spec: CouponSpec) -> None:
   397	        """F1 board should have return vias around the signal via."""
   398	        resolved = resolve(f1_spec)
   399	        writer = BoardWriter(f1_spec, resolved)
   400	        board = writer.build_board()
   401	
   402	        vias = [e for e in board if isinstance(e, list) and e[0] == "via"]
   403	        # 1 signal via + 4 return vias = 5 total
   404	        assert len(vias) == 5
   405	
   406	    def test_f1_board_has_two_footprints(self, f1_spec: CouponSpec) -> None:
   407	        """F1 board should have exactly two footprints (left and right connectors)."""
   408	        resolved = resolve(f1_spec)
   409	        writer = BoardWriter(f1_spec, resolved)
   410	        board = writer.build_board()
   411	
   412	        footprints = [e for e in board if isinstance(e, list) and e[0] == "footprint"]
   413	        assert len(footprints) == 2
   414	
   415	    def test_f1_board_has_board_outline(self, f1_spec: CouponSpec) -> None:
   416	        """F1 board should have a board outline on Edge.Cuts."""
   417	        resolved = resolve(f1_spec)
   418	        writer = BoardWriter(f1_spec, resolved)
   419	        board = writer.build_board()
   420	
   421	        gr_rects = [e for e in board if isinstance(e, list) and e[0] == "gr_rect"]
   422	        assert len(gr_rects) == 1
   423	
   424	    def test_f1_board_has_antipads_as_zones(self, f1_spec: CouponSpec) -> None:
   425	        """F1 board should have antipads as keepout zones."""
   426	        resolved = resolve(f1_spec)
   427	        writer = BoardWriter(f1_spec, resolved)
   428	        board = writer.build_board()
   429	
   430	        zones = [e for e in board if isinstance(e, list) and e[0] == "zone"]
   431	        # 2 antipads + 1 cutout = 3 zones
   432	        assert len(zones) >= 2
   433	
   434	    def test_f1_board_minimal_no_return_vias(self, f1_spec_minimal: CouponSpec) -> None:
   435	        """F1 minimal board should have only signal via."""
   436	        resolved = resolve(f1_spec_minimal)
   437	        writer = BoardWriter(f1_spec_minimal, resolved)
   438	        board = writer.build_board()
   439	
   440	        vias = [e for e in board if isinstance(e, list) and e[0] == "via"]
   441	        assert len(vias) == 1  # Only signal via
   442	
   443	
   444	class TestF1BoardDeterminism:
   445	    """Tests for F1 board generation determinism."""
   446	
   447	    def test_f1_board_text_deterministic(self, f1_spec: CouponSpec) -> None:
   448	        """Same F1 spec should produce identical board text."""
   449	        resolved = resolve(f1_spec)
   450	        text1 = build_board_text(f1_spec, resolved)
   451	        text2 = build_board_text(f1_spec, resolved)
   452	        assert text1 == text2
   453	
   454	    def test_f1_write_board_deterministic(self, f1_spec: CouponSpec, tmp_path: Path) -> None:
   455	        """Same F1 spec should produce identical board files."""
   456	        resolved = resolve(f1_spec)
   457	        board_path1 = write_board(f1_spec, resolved, tmp_path / "run1")
   458	        board_path2 = write_board(f1_spec, resolved, tmp_path / "run2")
   459	
   460	        content1 = board_path1.read_text(encoding="utf-8")
   461	        content2 = board_path2.read_text(encoding="utf-8")
   462	        assert content1 == content2
   463	
   464	    def test_f1_board_parseable(self, f1_spec: CouponSpec, tmp_path: Path) -> None:
   465	        """Generated F1 board should be parseable S-expression."""
   466	        resolved = resolve(f1_spec)
   467	        board_path = write_board(f1_spec, resolved, tmp_path)
   468	
   469	        content = board_path.read_text(encoding="utf-8")
   470	        parsed = parse(content)
   471	        assert parsed[0] == "kicad_pcb"
   472	
   473	
   474	class TestF1ViaGeometry:
   475	    """Tests for F1 via geometry correctness."""
   476	
   477	    def test_f1_signal_via_at_discontinuity(self, f1_spec: CouponSpec) -> None:
   478	        """F1 signal via should be at the discontinuity center."""
   479	        resolved = resolve(f1_spec)
   480	        layout = resolved.layout_plan
   481	        assert layout is not None
   482	        assert layout.x_disc_nm is not None
   483	
   484	        writer = BoardWriter(f1_spec, resolved)
   485	        board = writer.build_board()
   486	
   487	        vias = [e for e in board if isinstance(e, list) and e[0] == "via"]
   488	        assert len(vias) >= 1
   489	
   490	        # First via should be signal via at discontinuity
   491	        signal_via = vias[0]
   492	        at_elem = [e for e in signal_via if isinstance(e, list) and e[0] == "at"][0]
   493	        via_x_mm = float(at_elem[1])
   494	        via_x_nm = int(via_x_mm * 1_000_000)
   495	
   496	        # Should be at discontinuity position (within tolerance)
   497	        assert abs(via_x_nm - layout.x_disc_nm) < 1000  # 1um tolerance
   498	
   499	    def test_f1_return_vias_around_signal_via(self, f1_spec: CouponSpec) -> None:
   500	        """F1 return vias should be at correct radius from signal via."""
   501	        resolved = resolve(f1_spec)
   502	        layout = resolved.layout_plan
   503	        assert layout is not None
   504	        assert layout.x_disc_nm is not None
   505	
   506	        writer = BoardWriter(f1_spec, resolved)
   507	        board = writer.build_board()
   508	
   509	        vias = [e for e in board if isinstance(e, list) and e[0] == "via"]
   510	        assert len(vias) == 5  # 1 signal + 4 return
   511	
   512	        # Get expected radius from spec
   513	        expected_radius_nm = f1_spec.discontinuity.return_vias.radius_nm
   514	
   515	        # Check return vias (skip first which is signal via)
   516	        center_x_nm = layout.x_disc_nm
   517	        center_y_nm = layout.y_centerline_nm
   518	
   519	        for return_via in vias[1:]:
   520	            at_elem = [e for e in return_via if isinstance(e, list) and e[0] == "at"][0]
   521	            via_x_mm = float(at_elem[1])
   522	            via_y_mm = float(at_elem[2])
   523	            via_x_nm = int(via_x_mm * 1_000_000)
   524	            via_y_nm = int(via_y_mm * 1_000_000)
   525	
   526	            # Calculate distance from center
   527	            dx = via_x_nm - center_x_nm
   528	            dy = via_y_nm - center_y_nm
   529	            distance = (dx**2 + dy**2) ** 0.5
   530	
   531	            # Should be at expected radius (within tolerance)
   532	            assert abs(distance - expected_radius_nm) < 1000  # 1um tolerance
   533	
   534	
   535	class TestF1TrackGeometry:
   536	    """Tests for F1 track geometry correctness."""
   537	
   538	    def test_f1_tracks_on_correct_layer(self, f1_spec: CouponSpec) -> None:
   539	        """F1 tracks should be on the specified layer."""
   540	        resolved = resolve(f1_spec)
   541	        writer = BoardWriter(f1_spec, resolved)
   542	        board = writer.build_board()
   543	
   544	        segments = [e for e in board if isinstance(e, list) and e[0] == "segment"]
   545	        for segment in segments:
   546	            layer_elem = [e for e in segment if isinstance(e, list) and e[0] == "layer"][0]
   547	            assert layer_elem[1] == "F.Cu"
   548	
   549	    def test_f1_tracks_have_correct_width(self, f1_spec: CouponSpec) -> None:
   550	        """F1 tracks should have the correct width from spec."""
   551	        resolved = resolve(f1_spec)
   552	        writer = BoardWriter(f1_spec, resolved)
   553	        board = writer.build_board()
   554	
   555	        segments = [e for e in board if isinstance(e, list) and e[0] == "segment"]
   556	        for segment in segments:
   557	            width_elem = [e for e in segment if isinstance(e, list) and e[0] == "width"][0]
   558	            # Width in mm = 300000 nm / 1000000 = 0.3 mm
   559	            assert width_elem[1] == "0.3"
   560	
   561	    def test_f1_tracks_on_signal_net(self, f1_spec: CouponSpec) -> None:
   562	        """F1 tracks should be on the SIG net (net 1)."""
   563	        resolved = resolve(f1_spec)
   564	        writer = BoardWriter(f1_spec, resolved)
   565	        board = writer.build_board()
   566	
   567	        segments = [e for e in board if isinstance(e, list) and e[0] == "segment"]
   568	        for segment in segments:
   569	            net_elem = [e for e in segment if isinstance(e, list) and e[0] == "net"][0]
   570	            assert net_elem[1] == 1
   571	
   572	    def test_f1_tracks_meet_at_discontinuity(self, f1_spec: CouponSpec) -> None:
   573	        """F1 tracks should meet at the discontinuity center."""
   574	        resolved = resolve(f1_spec)
   575	        layout = resolved.layout_plan
   576	        assert layout is not None
   577	        assert layout.x_disc_nm is not None
   578	
   579	        writer = BoardWriter(f1_spec, resolved)
   580	        board = writer.build_board()
   581	
   582	        segments = [e for e in board if isinstance(e, list) and e[0] == "segment"]
   583	        assert len(segments) == 2
   584	
   585	        # Get endpoints
   586	        endpoints = []
   587	        for segment in segments:
   588	            start_elem = [e for e in segment if isinstance(e, list) and e[0] == "start"][0]
   589	            end_elem = [e for e in segment if isinstance(e, list) and e[0] == "end"][0]
   590	            endpoints.append(float(start_elem[1]))
   591	            endpoints.append(float(end_elem[1]))
   592	
   593	        # Convert discontinuity x to mm
   594	        disc_x_mm = layout.x_disc_nm / 1_000_000
   595	
   596	        # At least one endpoint should be at discontinuity (from each segment)
   597	        at_disc = [x for x in endpoints if abs(x - disc_x_mm) < 0.001]
   598	        assert len(at_disc) == 2  # Both segments meet at discontinuity
   599	
   600	
   601	class TestF1GoldenSpecs:
   602	    """Tests for F1 golden specification files."""
   603	
   604	    def test_f1_golden_specs_exist(self) -> None:
   605	        """At least 10 F1 golden specs should exist."""
   606	        f1_specs = _collect_f1_golden_specs()
   607	        assert len(f1_specs) >= 10, f"Expected >= 10 F1 specs, found {len(f1_specs)}"
   608	
   609	    @pytest.mark.parametrize(
   610	        "spec_path",
   611	        _collect_f1_golden_specs()[:5],  # Test first 5 for speed
   612	        ids=lambda p: p.stem,
   613	    )
   614	    def test_f1_golden_spec_loads(self, spec_path: Path) -> None:
   615	        """Each F1 golden spec should load successfully."""
   616	        with open(spec_path, encoding="utf-8") as f:
   617	            data = yaml.safe_load(f)
   618	
   619	        spec = CouponSpec.model_validate(data)
   620	        assert spec.coupon_family == FAMILY_F1
   621	        assert spec.discontinuity is not None
   622	
   623	    @pytest.mark.parametrize(
   624	        "spec_path",
   625	        _collect_f1_golden_specs()[:5],
   626	        ids=lambda p: p.stem,
   627	    )
   628	    def test_f1_golden_spec_resolves(self, spec_path: Path) -> None:
   629	        """Each F1 golden spec should resolve to a valid design."""
   630	        with open(spec_path, encoding="utf-8") as f:
   631	            data = yaml.safe_load(f)
   632	
   633	        spec = CouponSpec.model_validate(data)
   634	        resolved = resolve(spec)
   635	
   636	        assert resolved is not None
   637	        assert resolved.layout_plan is not None
   638	        assert resolved.layout_plan.has_discontinuity
   639	
   640	    @pytest.mark.parametrize(
   641	        "spec_path",
   642	        _collect_f1_golden_specs()[:5],
   643	        ids=lambda p: p.stem,
   644	    )
   645	    def test_f1_golden_spec_generates_board(self, spec_path: Path, tmp_path: Path) -> None:
   646	        """Each F1 golden spec should generate a valid board file."""
   647	        with open(spec_path, encoding="utf-8") as f:
   648	            data = yaml.safe_load(f)
   649	
   650	        spec = CouponSpec.model_validate(data)
   651	        resolved = resolve(spec)
   652	        board_path = write_board(spec, resolved, tmp_path)
   653	
   654	        assert board_path.exists()
   655	        content = board_path.read_text(encoding="utf-8")
   656	        assert content.strip().startswith("(kicad_pcb")
   657	        assert content.count("(") == content.count(")")
   658	
   659	
   660	class TestF1EndToEndPipeline:
   661	    """End-to-end integration tests for F1 pipeline."""
   662	
   663	    def test_f1_full_pipeline(self, f1_spec: CouponSpec, tmp_path: Path) -> None:
   664	        """Test complete F1 pipeline: spec -> resolve -> board."""
   665	        # Step 1: Resolve spec
   666	        resolved = resolve(f1_spec)
   667	        assert resolved is not None
   668	
   669	        # Step 2: Verify LayoutPlan
   670	        layout = resolved.layout_plan
   671	        assert layout is not None
   672	        assert len(layout.segments) == 2
   673	        assert layout.has_discontinuity
   674	
   675	        # Step 3: Build F1 composition
   676	        composition = build_f1_coupon(f1_spec, resolved)
   677	        assert isinstance(composition, F1CouponComposition)
   678	
   679	        # Step 4: Generate board
   680	        board_path = write_board(f1_spec, resolved, tmp_path)
   681	        assert board_path.exists()
   682	
   683	        # Step 5: Verify board contents
   684	        content = board_path.read_text(encoding="utf-8")
   685	        parsed = parse(content)
   686	
   687	        # Should have expected elements
   688	        segments = [e for e in parsed if isinstance(e, list) and e[0] == "segment"]
   689	        footprints = [e for e in parsed if isinstance(e, list) and e[0] == "footprint"]
   690	        vias = [e for e in parsed if isinstance(e, list) and e[0] == "via"]
   691	        zones = [e for e in parsed if isinstance(e, list) and e[0] == "zone"]
   692	
   693	        assert len(segments) == 2, "F1 should have exactly 2 track segments"
   694	        assert len(footprints) == 2, "F1 should have exactly 2 footprints"
   695	        assert len(vias) == 5, "F1 should have 5 vias (1 signal + 4 return)"
   696	        assert len(zones) >= 2, "F1 should have antipads/cutouts as zones"
   697	
   698	    def test_f1_api_pipeline(self, tmp_path: Path) -> None:
   699	        """Test F1 pipeline using the public API functions."""
   700	        # Create spec file
   701	        spec_data = _minimal_f1_spec_data()
   702	        spec_file = tmp_path / "f1_test.json"
   703	        spec_file.write_text(json.dumps(spec_data), encoding="utf-8")
   704	
   705	        # Load and validate spec
   706	        spec = load_spec(spec_file)
   707	        assert spec.coupon_family == FAMILY_F1
   708	
   709	        # Resolve spec
   710	        resolved = resolve_spec(spec)
   711	        assert resolved is not None
   712	
   713	        # Generate KiCad project
   714	        project = generate_kicad(resolved, spec, tmp_path / "output")
   715	        assert project.board_path.exists()
   716	
   717	        # Verify board file
   718	        content = project.board_path.read_text(encoding="utf-8")
   719	        assert "(kicad_pcb" in content
   720	        assert "(via" in content  # Should have vias
   721	
   722	    def test_f1_geometry_matches_layout_plan(self, f1_spec: CouponSpec) -> None:
   723	        """Board geometry should exactly match LayoutPlan."""
   724	        resolved = resolve(f1_spec)
   725	        layout = resolved.layout_plan
   726	        assert layout is not None
   727	
   728	        writer = BoardWriter(f1_spec, resolved)
   729	        board = writer.build_board()
   730	
   731	        # Get board outline from S-expr
   732	        gr_rects = [e for e in board if isinstance(e, list) and e[0] == "gr_rect"]
   733	        assert len(gr_rects) == 1
   734	        rect = gr_rects[0]
   735	
   736	        # Get start/end coords (in mm)
   737	        start_elem = [e for e in rect if isinstance(e, list) and e[0] == "start"][0]
   738	        end_elem = [e for e in rect if isinstance(e, list) and e[0] == "end"][0]
   739	
   740	        # Convert back to nm for comparison
   741	        start_x_nm = int(float(start_elem[1]) * 1_000_000)
   742	        end_x_nm = int(float(end_elem[1]) * 1_000_000)
   743	
   744	        # Should match LayoutPlan board dimensions
   745	        assert start_x_nm == layout.x_board_left_edge_nm
   746	        assert end_x_nm == layout.x_board_right_edge_nm
   747	
   748	        # Check signal via at discontinuity
   749	        vias = [e for e in board if isinstance(e, list) and e[0] == "via"]
   750	        signal_via = vias[0]
   751	        at_elem = [e for e in signal_via if isinstance(e, list) and e[0] == "at"][0]
   752	        via_x_nm = int(float(at_elem[1]) * 1_000_000)
   753	
   754	        assert layout.x_disc_nm is not None
   755	        assert abs(via_x_nm - layout.x_disc_nm) < 1000  # 1um tolerance
   756	
   757	    def test_f1_connectivity_invariant(self, f1_spec: CouponSpec) -> None:
   758	        """F1 should maintain connectivity invariant: segments meet at via."""
   759	        resolved = resolve(f1_spec)
   760	        layout = resolved.layout_plan
   761	        assert layout is not None
   762	
   763	        # Verify connectivity invariant
   764	        errors = layout.validate_connectivity()
   765	        assert errors == [], f"Connectivity errors: {errors}"
   766	
   767	        # Verify left segment end == discontinuity == right segment start
   768	        left_seg = layout.get_segment_by_label("left")
   769	        right_seg = layout.get_segment_by_label("right")
   770	        assert left_seg is not None
   771	        assert right_seg is not None
   772	        assert layout.x_disc_nm is not None
   773	
   774	        assert left_seg.x_end_nm == layout.x_disc_nm
   775	        assert right_seg.x_start_nm == layout.x_disc_nm
   776	        assert left_seg.x_end_nm == right_seg.x_start_nm
   777	
   778	
   779	class TestF1RequirementCoverage:
   780	    """Tests to verify REQ-M1-007 coverage for F1 coupons."""
   781	
   782	    def test_req_m1_007_end_launch_connectors(self, f1_spec: CouponSpec) -> None:
   783	        """REQ-M1-007: F1 has end-launch connectors at both ends."""
   784	        resolved = resolve(f1_spec)
   785	        composition = build_f1_coupon(f1_spec, resolved)
   786	
   787	        assert composition.left_port is not None
   788	        assert composition.right_port is not None
   789	        assert composition.left_port.side == "left"
   790	        assert composition.right_port.side == "right"
   791	
   792	    def test_req_m1_007_cpwg_on_both_sides(self, f1_spec: CouponSpec) -> None:
   793	        """REQ-M1-007: F1 has CPWG on both sides of via transition."""
   794	        resolved = resolve(f1_spec)
   795	        composition = build_f1_coupon(f1_spec, resolved)
   796	
   797	        tl = composition.transmission_line
   798	        assert tl.length_left_nm > 0
   799	        assert tl.length_right_nm > 0
   800	
   801	        # Verify track segments
   802	        left_track, right_track = tl.to_track_segments()
   803	        assert left_track is not None
   804	        assert right_track is not None
   805	
   806	    def test_req_m1_007_via_transition(self, f1_spec: CouponSpec) -> None:
   807	        """REQ-M1-007: F1 has via transition (top to inner or top to bottom)."""
   808	        resolved = resolve(f1_spec)
   809	        composition = build_f1_coupon(f1_spec, resolved)
   810	
   811	        via = composition.signal_via
   812	        assert via is not None
   813	        assert via.layers == ("F.Cu", "B.Cu")  # Top to bottom
   814	
   815	    def test_req_m1_007_antipads_cutouts(self, f1_spec: CouponSpec) -> None:
   816	        """REQ-M1-007: F1 includes antipads/cutouts."""
   817	        resolved = resolve(f1_spec)
   818	        composition = build_f1_coupon(f1_spec, resolved)
   819	
   820	        antipads = composition.all_antipads
   821	        assert len(antipads) > 0
   822	
   823	        cutouts = composition.all_cutouts
   824	        assert len(cutouts) > 0
   825	
   826	    def test_req_m1_007_return_vias(self, f1_spec: CouponSpec) -> None:
   827	        """REQ-M1-007: F1 includes return vias."""
   828	        resolved = resolve(f1_spec)
   829	        composition = build_f1_coupon(f1_spec, resolved)
   830	
   831	        return_vias = composition.return_vias
   832	        assert len(return_vias) > 0

================================================================================
FILE: tests/test_m1_board_writer.py
================================================================================
     1	"""Tests for board writer and deterministic UUID generation (REQ-M1-012, REQ-M1-013)."""
     2	
     3	from __future__ import annotations
     4	
     5	import uuid
     6	from pathlib import Path
     7	
     8	import pytest
     9	
    10	from formula_foundry.coupongen.kicad import (
    11	    BoardWriter,
    12	    build_board_text,
    13	    deterministic_uuid,
    14	    deterministic_uuid_indexed,
    15	    parse,
    16	    write_board,
    17	)
    18	from formula_foundry.coupongen.kicad.board_writer import (
    19	    SPEC_TO_KICAD_LAYER,
    20	    map_layer_to_kicad,
    21	)
    22	from formula_foundry.coupongen.resolve import resolve
    23	from formula_foundry.coupongen.spec import CouponSpec
    24	
    25	
    26	@pytest.fixture
    27	def f0_spec_data() -> dict:
    28	    """Minimal F0 calibration spec data."""
    29	    return {
    30	        "schema_version": 1,
    31	        "coupon_family": "F0_CAL_THRU_LINE",
    32	        "units": "nm",
    33	        "toolchain": {
    34	            "kicad": {
    35	                "version": "9.0.7",
    36	                "docker_image": "kicad/kicad:9.0.7@sha256:deadbeef",
    37	            }
    38	        },
    39	        "fab_profile": {"id": "oshpark_4layer", "overrides": {}},
    40	        "stackup": {
    41	            "copper_layers": 4,
    42	            "thicknesses_nm": {
    43	                "L1_to_L2": 180000,
    44	                "L2_to_L3": 800000,
    45	                "L3_to_L4": 180000,
    46	            },
    47	            "materials": {"er": 4.1, "loss_tangent": 0.02},
    48	        },
    49	        "board": {
    50	            "outline": {
    51	                "width_nm": 20000000,
    52	                "length_nm": 80000000,
    53	                "corner_radius_nm": 2000000,
    54	            },
    55	            "origin": {"mode": "EDGE_L_CENTER"},
    56	            "text": {"coupon_id": "${COUPON_ID}", "include_manifest_hash": True},
    57	        },
    58	        "connectors": {
    59	            "left": {
    60	                "footprint": "Coupongen_Connectors:SMA_EndLaunch_Generic",
    61	                "position_nm": [5000000, 0],
    62	                "rotation_deg": 180,
    63	            },
    64	            "right": {
    65	                "footprint": "Coupongen_Connectors:SMA_EndLaunch_Generic",
    66	                "position_nm": [75000000, 0],
    67	                "rotation_deg": 0,
    68	            },
    69	        },
    70	        "transmission_line": {
    71	            "type": "CPWG",
    72	            "layer": "F.Cu",
    73	            "w_nm": 300000,
    74	            "gap_nm": 180000,
    75	            "length_left_nm": 25000000,
    76	            "length_right_nm": 25000000,
    77	        },
    78	        "discontinuity": None,
    79	        "constraints": {
    80	            "mode": "REJECT",
    81	            "drc": {"must_pass": True, "severity": "all"},
    82	            "symmetry": {"enforce": True},
    83	            "allow_unconnected_copper": False,
    84	        },
    85	        "export": {
    86	            "gerbers": {"enabled": True, "format": "gerbers"},
    87	            "drill": {"enabled": True, "format": "excellon"},
    88	            "outputs_dir": "artifacts/",
    89	        },
    90	    }
    91	
    92	
    93	@pytest.fixture
    94	def f1_spec_data(f0_spec_data: dict) -> dict:
    95	    """F1 via transition spec data."""
    96	    spec = f0_spec_data.copy()
    97	    spec["coupon_family"] = "F1_SINGLE_ENDED_VIA"
    98	    spec["discontinuity"] = {
    99	        "type": "VIA_TRANSITION",
   100	        "signal_via": {
   101	            "drill_nm": 300000,
   102	            "diameter_nm": 650000,
   103	            "pad_diameter_nm": 900000,
   104	        },
   105	        "antipads": {},
   106	        "return_vias": {
   107	            "pattern": "RING",
   108	            "count": 4,
   109	            "radius_nm": 1700000,
   110	            "via": {"drill_nm": 300000, "diameter_nm": 650000},
   111	        },
   112	        "plane_cutouts": {},
   113	    }
   114	    return spec
   115	
   116	
   117	@pytest.fixture
   118	def f0_spec(f0_spec_data: dict) -> CouponSpec:
   119	    return CouponSpec.model_validate(f0_spec_data)
   120	
   121	
   122	@pytest.fixture
   123	def f1_spec(f1_spec_data: dict) -> CouponSpec:
   124	    return CouponSpec.model_validate(f1_spec_data)
   125	
   126	
   127	class TestDeterministicUuid:
   128	    """Tests for deterministic UUIDv5 generation."""
   129	
   130	    def test_uuid_format(self) -> None:
   131	        """UUID should be valid UUID format."""
   132	        result = deterministic_uuid(1, "test.path")
   133	        # Should parse as valid UUID
   134	        parsed = uuid.UUID(result)
   135	        assert str(parsed) == result
   136	
   137	    def test_uuid_deterministic(self) -> None:
   138	        """Same inputs should produce same UUID."""
   139	        uuid1 = deterministic_uuid(1, "board.outline")
   140	        uuid2 = deterministic_uuid(1, "board.outline")
   141	        assert uuid1 == uuid2
   142	
   143	    def test_uuid_different_paths(self) -> None:
   144	        """Different paths should produce different UUIDs."""
   145	        uuid1 = deterministic_uuid(1, "board.outline")
   146	        uuid2 = deterministic_uuid(1, "connector.left")
   147	        assert uuid1 != uuid2
   148	
   149	    def test_uuid_different_versions(self) -> None:
   150	        """Different schema versions should produce different UUIDs."""
   151	        uuid1 = deterministic_uuid(1, "board.outline")
   152	        uuid2 = deterministic_uuid(2, "board.outline")
   153	        assert uuid1 != uuid2
   154	
   155	    def test_uuid_indexed(self) -> None:
   156	        """Indexed UUIDs should be deterministic."""
   157	        uuid1 = deterministic_uuid_indexed(1, "via.return", 0)
   158	        uuid2 = deterministic_uuid_indexed(1, "via.return", 0)
   159	        assert uuid1 == uuid2
   160	
   161	        uuid3 = deterministic_uuid_indexed(1, "via.return", 1)
   162	        assert uuid1 != uuid3
   163	
   164	
   165	class TestBoardWriter:
   166	    """Tests for BoardWriter class."""
   167	
   168	    def test_writer_creates_valid_sexpr(self, f0_spec: CouponSpec) -> None:
   169	        """Writer should produce parseable S-expression."""
   170	        resolved = resolve(f0_spec)
   171	        writer = BoardWriter(f0_spec, resolved)
   172	        board = writer.build_board()
   173	
   174	        # Should be a list starting with 'kicad_pcb'
   175	        assert isinstance(board, list)
   176	        assert board[0] == "kicad_pcb"
   177	
   178	    def test_writer_includes_version(self, f0_spec: CouponSpec) -> None:
   179	        """Board should include version header."""
   180	        resolved = resolve(f0_spec)
   181	        writer = BoardWriter(f0_spec, resolved)
   182	        board = writer.build_board()
   183	
   184	        # Find version element
   185	        version_elem = [e for e in board if isinstance(e, list) and e[0] == "version"]
   186	        assert len(version_elem) == 1
   187	        assert version_elem[0][1] == 20240101
   188	
   189	    def test_writer_includes_nets(self, f0_spec: CouponSpec) -> None:
   190	        """Board should include net declarations."""
   191	        resolved = resolve(f0_spec)
   192	        writer = BoardWriter(f0_spec, resolved)
   193	        board = writer.build_board()
   194	
   195	        # Find net elements
   196	        net_elems = [e for e in board if isinstance(e, list) and e[0] == "net"]
   197	        assert len(net_elems) >= 3
   198	        # Should have nets 0 (unconnected), 1 (SIG), 2 (GND)
   199	        net_ids = [e[1] for e in net_elems]
   200	        assert 0 in net_ids
   201	        assert 1 in net_ids
   202	        assert 2 in net_ids
   203	
   204	    def test_writer_includes_outline(self, f0_spec: CouponSpec) -> None:
   205	        """Board should include Edge.Cuts outline."""
   206	        resolved = resolve(f0_spec)
   207	        writer = BoardWriter(f0_spec, resolved)
   208	        board = writer.build_board()
   209	
   210	        # Find gr_rect element
   211	        gr_rect = [e for e in board if isinstance(e, list) and e[0] == "gr_rect"]
   212	        assert len(gr_rect) == 1
   213	
   214	    def test_writer_includes_footprints(self, f0_spec: CouponSpec) -> None:
   215	        """Board should include connector footprints."""
   216	        resolved = resolve(f0_spec)
   217	        writer = BoardWriter(f0_spec, resolved)
   218	        board = writer.build_board()
   219	
   220	        # Find footprint elements
   221	        footprints = [e for e in board if isinstance(e, list) and e[0] == "footprint"]
   222	        assert len(footprints) == 2  # left and right connectors
   223	
   224	    def test_writer_includes_tracks(self, f0_spec: CouponSpec) -> None:
   225	        """Board should include track segments."""
   226	        resolved = resolve(f0_spec)
   227	        writer = BoardWriter(f0_spec, resolved)
   228	        board = writer.build_board()
   229	
   230	        # Find segment elements
   231	        segments = [e for e in board if isinstance(e, list) and e[0] == "segment"]
   232	        # F0 (calibration through-line) has a single continuous trace from
   233	        # left to right connector. This is correct per LayoutPlan model.
   234	        assert len(segments) == 1  # single through-line track for F0
   235	
   236	    def test_writer_f1_includes_vias(self, f1_spec: CouponSpec) -> None:
   237	        """F1 board should include signal and return vias."""
   238	        resolved = resolve(f1_spec)
   239	        writer = BoardWriter(f1_spec, resolved)
   240	        board = writer.build_board()
   241	
   242	        # Find via elements
   243	        vias = [e for e in board if isinstance(e, list) and e[0] == "via"]
   244	        assert len(vias) == 5  # 1 signal + 4 return vias
   245	
   246	
   247	class TestBuildBoardText:
   248	    """Tests for build_board_text function."""
   249	
   250	    def test_build_board_text_parseable(self, f0_spec: CouponSpec) -> None:
   251	        """Generated text should be parseable S-expression."""
   252	        resolved = resolve(f0_spec)
   253	        text = build_board_text(f0_spec, resolved)
   254	
   255	        # Should parse without error
   256	        parsed = parse(text)
   257	        assert parsed[0] == "kicad_pcb"
   258	
   259	    def test_build_board_text_deterministic(self, f0_spec: CouponSpec) -> None:
   260	        """Same inputs should produce same output."""
   261	        resolved = resolve(f0_spec)
   262	        text1 = build_board_text(f0_spec, resolved)
   263	        text2 = build_board_text(f0_spec, resolved)
   264	        assert text1 == text2
   265	
   266	
   267	class TestWriteBoard:
   268	    """Tests for write_board function."""
   269	
   270	    def test_write_board_creates_file(self, f0_spec: CouponSpec, tmp_path: Path) -> None:
   271	        """write_board should create a .kicad_pcb file."""
   272	        resolved = resolve(f0_spec)
   273	        board_path = write_board(f0_spec, resolved, tmp_path)
   274	
   275	        assert board_path.exists()
   276	        assert board_path.name == "coupon.kicad_pcb"
   277	
   278	    def test_write_board_content_parseable(self, f0_spec: CouponSpec, tmp_path: Path) -> None:
   279	        """Written file should contain parseable S-expression."""
   280	        resolved = resolve(f0_spec)
   281	        board_path = write_board(f0_spec, resolved, tmp_path)
   282	
   283	        content = board_path.read_text(encoding="utf-8")
   284	        parsed = parse(content)
   285	        assert parsed[0] == "kicad_pcb"
   286	
   287	    def test_write_board_deterministic_tstamps(self, f0_spec: CouponSpec, tmp_path: Path) -> None:
   288	        """Written file should have deterministic tstamp values."""
   289	        resolved = resolve(f0_spec)
   290	        board_path1 = write_board(f0_spec, resolved, tmp_path / "run1")
   291	        board_path2 = write_board(f0_spec, resolved, tmp_path / "run2")
   292	
   293	        content1 = board_path1.read_text(encoding="utf-8")
   294	        content2 = board_path2.read_text(encoding="utf-8")
   295	
   296	        # Files should be identical
   297	        assert content1 == content2
   298	
   299	    def test_write_board_f1_with_vias(self, f1_spec: CouponSpec, tmp_path: Path) -> None:
   300	        """F1 board file should contain via elements."""
   301	        resolved = resolve(f1_spec)
   302	        board_path = write_board(f1_spec, resolved, tmp_path)
   303	
   304	        content = board_path.read_text(encoding="utf-8")
   305	        assert "(via" in content
   306	        # Should have signal via and return vias (at least 1 signal + 4 return)
   307	        via_count = content.count("(via")
   308	        assert via_count >= 5, f"Expected at least 5 vias (1 signal + 4 return), got {via_count}"
   309	
   310	
   311	@pytest.fixture
   312	def f1_spec_with_antipads(f1_spec_data: dict) -> CouponSpec:
   313	    """F1 spec with antipads and cutouts configured."""
   314	    spec = f1_spec_data.copy()
   315	    spec["discontinuity"] = {
   316	        "type": "VIA_TRANSITION",
   317	        "signal_via": {
   318	            "drill_nm": 300000,
   319	            "diameter_nm": 650000,
   320	            "pad_diameter_nm": 900000,
   321	        },
   322	        "antipads": {
   323	            "In1.Cu": {
   324	                "shape": "ROUNDRECT",
   325	                "rx_nm": 1200000,
   326	                "ry_nm": 900000,
   327	                "corner_nm": 250000,
   328	            },
   329	            "In2.Cu": {
   330	                "shape": "CIRCLE",
   331	                "r_nm": 1100000,
   332	            },
   333	        },
   334	        "return_vias": {
   335	            "pattern": "RING",
   336	            "count": 4,
   337	            "radius_nm": 1700000,
   338	            "via": {"drill_nm": 300000, "diameter_nm": 650000},
   339	        },
   340	        "plane_cutouts": {
   341	            "In1.Cu": {
   342	                "shape": "SLOT",
   343	                "length_nm": 3000000,
   344	                "width_nm": 1500000,
   345	                "rotation_deg": 0,
   346	            },
   347	        },
   348	    }
   349	    return CouponSpec.model_validate(spec)
   350	
   351	
   352	class TestF1BoardWriterWithAntipads:
   353	    """Tests for F1 board generation with antipads and cutouts (REQ-M1-007)."""
   354	
   355	    def test_f1_via_position_uses_composition(self, f1_spec: CouponSpec) -> None:
   356	        """Signal via should be at discontinuity position from builder composition."""
   357	        from formula_foundry.coupongen.builders.f1_builder import build_f1_coupon
   358	        from formula_foundry.coupongen.kicad.sexpr import nm_to_mm
   359	
   360	        resolved = resolve(f1_spec)
   361	        composition = build_f1_coupon(f1_spec, resolved)
   362	        writer = BoardWriter(f1_spec, resolved)
   363	        board = writer.build_board()
   364	
   365	        # Find signal via
   366	        vias = [e for e in board if isinstance(e, list) and e[0] == "via"]
   367	        signal_via = vias[0]  # First via is signal via
   368	
   369	        # Extract position
   370	        at_elem = [e for e in signal_via if isinstance(e, list) and e[0] == "at"][0]
   371	        via_x_mm = at_elem[1]
   372	        via_y_mm = at_elem[2]
   373	
   374	        # Verify position matches composition
   375	        expected_x_mm = nm_to_mm(composition.discontinuity_position.x)
   376	        expected_y_mm = nm_to_mm(composition.discontinuity_position.y)
   377	
   378	        assert via_x_mm == expected_x_mm
   379	        assert via_y_mm == expected_y_mm
   380	
   381	    def test_f1_board_includes_antipads(self, f1_spec_with_antipads: CouponSpec, tmp_path: Path) -> None:
   382	        """F1 board with antipads should include zone keepouts."""
   383	        resolved = resolve(f1_spec_with_antipads)
   384	        board_path = write_board(f1_spec_with_antipads, resolved, tmp_path)
   385	
   386	        content = board_path.read_text(encoding="utf-8")
   387	
   388	        # Should have zone elements for antipads
   389	        assert "(zone" in content
   390	        # Should have zones on internal layers (unquoted in KiCad S-expr format)
   391	        assert "In1.Cu" in content
   392	
   393	    def test_f1_board_includes_cutouts(self, f1_spec_with_antipads: CouponSpec, tmp_path: Path) -> None:
   394	        """F1 board with plane cutouts should include zone keepouts."""
   395	        resolved = resolve(f1_spec_with_antipads)
   396	        board_path = write_board(f1_spec_with_antipads, resolved, tmp_path)
   397	
   398	        content = board_path.read_text(encoding="utf-8")
   399	
   400	        # Should have zone elements
   401	        zone_count = content.count("(zone")
   402	        # Should have antipads (2) + cutouts (1) = 3 zones
   403	        assert zone_count >= 3
   404	
   405	    def test_f1_antipad_zones_have_keepout(self, f1_spec_with_antipads: CouponSpec) -> None:
   406	        """Antipad zones should have keepout properties set."""
   407	        resolved = resolve(f1_spec_with_antipads)
   408	        writer = BoardWriter(f1_spec_with_antipads, resolved)
   409	        board = writer.build_board()
   410	
   411	        # Find zone elements
   412	        zones = [e for e in board if isinstance(e, list) and e[0] == "zone"]
   413	
   414	        # Each zone should have keepout element
   415	        for zone in zones:
   416	            keepout_elems = [e for e in zone if isinstance(e, list) and e[0] == "keepout"]
   417	            assert len(keepout_elems) == 1
   418	
   419	    def test_f1_return_vias_positioned_around_discontinuity(self, f1_spec: CouponSpec) -> None:
   420	        """Return vias should be positioned around the discontinuity center."""
   421	        from formula_foundry.coupongen.builders.f1_builder import build_f1_coupon
   422	
   423	        resolved = resolve(f1_spec)
   424	        composition = build_f1_coupon(f1_spec, resolved)
   425	        writer = BoardWriter(f1_spec, resolved)
   426	        board = writer.build_board()
   427	
   428	        # Find all vias
   429	        vias = [e for e in board if isinstance(e, list) and e[0] == "via"]
   430	
   431	        # Skip signal via (first one), check return vias
   432	        center_x = composition.discontinuity_position.x
   433	        center_y = composition.discontinuity_position.y
   434	        radius_nm = 1700000  # From spec
   435	
   436	        for via in vias[1:]:  # Skip signal via
   437	            at_elem = [e for e in via if isinstance(e, list) and e[0] == "at"][0]
   438	            via_x_mm_str = at_elem[1]
   439	            via_y_mm_str = at_elem[2]
   440	
   441	            # nm_to_mm returns strings, need to convert back to nm
   442	            via_x_nm = int(float(via_x_mm_str) * 1_000_000)
   443	            via_y_nm = int(float(via_y_mm_str) * 1_000_000)
   444	
   445	            # Calculate distance from center
   446	            dx = via_x_nm - center_x
   447	            dy = via_y_nm - center_y
   448	            distance = (dx**2 + dy**2) ** 0.5
   449	
   450	            # Should be approximately at radius_nm (allow small rounding error)
   451	            assert abs(distance - radius_nm) < 1000  # 1um tolerance
   452	
   453	    def test_f1_board_deterministic_with_antipads(self, f1_spec_with_antipads: CouponSpec, tmp_path: Path) -> None:
   454	        """F1 board with antipads should be deterministic."""
   455	        resolved = resolve(f1_spec_with_antipads)
   456	
   457	        board_path1 = write_board(f1_spec_with_antipads, resolved, tmp_path / "run1")
   458	        board_path2 = write_board(f1_spec_with_antipads, resolved, tmp_path / "run2")
   459	
   460	        content1 = board_path1.read_text(encoding="utf-8")
   461	        content2 = board_path2.read_text(encoding="utf-8")
   462	
   463	        assert content1 == content2
   464	
   465	    def test_f1_antipad_polygon_vertices(self, f1_spec_with_antipads: CouponSpec) -> None:
   466	        """Antipad zones should have polygon vertices."""
   467	        resolved = resolve(f1_spec_with_antipads)
   468	        writer = BoardWriter(f1_spec_with_antipads, resolved)
   469	        board = writer.build_board()
   470	
   471	        # Find zone elements
   472	        zones = [e for e in board if isinstance(e, list) and e[0] == "zone"]
   473	
   474	        # Each zone should have a polygon with pts
   475	        for zone in zones:
   476	            polygon_elems = [e for e in zone if isinstance(e, list) and e[0] == "polygon"]
   477	            assert len(polygon_elems) == 1
   478	
   479	            polygon = polygon_elems[0]
   480	            pts_elems = [e for e in polygon if isinstance(e, list) and e[0] == "pts"]
   481	            assert len(pts_elems) == 1
   482	
   483	            pts = pts_elems[0]
   484	            # Should have multiple xy points
   485	            xy_points = [e for e in pts if isinstance(e, list) and e[0] == "xy"]
   486	            assert len(xy_points) >= 3  # At least a triangle
   487	
   488	
   489	class TestF1RequirementCoverageInBoardWriter:
   490	    """Tests verifying REQ-M1-007 coverage in board writer."""
   491	
   492	    def test_req_m1_007_end_to_end_via_transition(self, f1_spec_with_antipads: CouponSpec, tmp_path: Path) -> None:
   493	        """REQ-M1-007: Full F1 coupon with all features generates valid board."""
   494	        resolved = resolve(f1_spec_with_antipads)
   495	        board_path = write_board(f1_spec_with_antipads, resolved, tmp_path)
   496	
   497	        content = board_path.read_text(encoding="utf-8")
   498	
   499	        # Verify all required elements are present
   500	        # 1. Board outline (Edge.Cuts)
   501	        assert "(gr_rect" in content
   502	        assert "Edge.Cuts" in content
   503	
   504	        # 2. Footprints (connectors) - count standalone "(footprint" at start of element
   505	        # Note: zones contain "footprints" as keepout attribute, so we count lines
   506	        import re
   507	
   508	        footprint_matches = re.findall(r"\(footprint\s+[\w:]+", content)
   509	        assert len(footprint_matches) == 2  # Left and right connectors
   510	
   511	        # 3. Transmission line tracks (left and right signal traces)
   512	        # Plus ground ring traces connecting return vias (4 vias x 2 layers = 8 traces)
   513	        assert "(segment" in content
   514	        segment_count = content.count("(segment")
   515	        assert segment_count >= 2, f"Expected at least 2 signal trace segments, got {segment_count}"
   516	
   517	        # 4. Signal via
   518	        assert "(via" in content
   519	
   520	        # 5. Return vias (4 vias in RING pattern)
   521	        # Count via elements (not "vias" attributes in keepout zones)
   522	        # Via elements start with "(via" followed by newline, not "(vias"
   523	        via_count = len(re.findall(r"\(via\n", content))
   524	        assert via_count >= 5, f"Expected at least 5 vias (1 signal + 4 return), got {via_count}"
   525	
   526	        # 6. Antipads (zones on internal layers)
   527	        assert "(zone" in content
   528	
   529	        # 7. Plane cutouts - zones for antipads (2) + cutouts (1) = 3
   530	        zone_count = content.count("(zone")
   531	        assert zone_count >= 3  # 2 antipads + 1 cutout
   532	
   533	
   534	class TestLayerMapping:
   535	    """Tests for spec layer name to KiCad layer name mapping."""
   536	
   537	    def test_map_layer_l1_to_fcu(self) -> None:
   538	        """L1 should map to F.Cu (front copper)."""
   539	        assert map_layer_to_kicad("L1") == "F.Cu"
   540	
   541	    def test_map_layer_l2_to_in1cu(self) -> None:
   542	        """L2 should map to In1.Cu (internal layer 1)."""
   543	        assert map_layer_to_kicad("L2") == "In1.Cu"
   544	
   545	    def test_map_layer_l3_to_in2cu(self) -> None:
   546	        """L3 should map to In2.Cu (internal layer 2)."""
   547	        assert map_layer_to_kicad("L3") == "In2.Cu"
   548	
   549	    def test_map_layer_l4_to_bcu(self) -> None:
   550	        """L4 should map to B.Cu (back copper)."""
   551	        assert map_layer_to_kicad("L4") == "B.Cu"
   552	
   553	    def test_map_layer_passthrough_fcu(self) -> None:
   554	        """KiCad layer names should pass through unchanged."""
   555	        assert map_layer_to_kicad("F.Cu") == "F.Cu"
   556	
   557	    def test_map_layer_passthrough_in1cu(self) -> None:
   558	        """KiCad layer names should pass through unchanged."""
   559	        assert map_layer_to_kicad("In1.Cu") == "In1.Cu"
   560	
   561	    def test_map_layer_passthrough_in2cu(self) -> None:
   562	        """KiCad layer names should pass through unchanged."""
   563	        assert map_layer_to_kicad("In2.Cu") == "In2.Cu"
   564	
   565	    def test_map_layer_passthrough_bcu(self) -> None:
   566	        """KiCad layer names should pass through unchanged."""
   567	        assert map_layer_to_kicad("B.Cu") == "B.Cu"
   568	
   569	    def test_map_layer_unknown_raises(self) -> None:
   570	        """Unknown layer names should raise ValueError."""
   571	        with pytest.raises(ValueError, match="Unknown layer name"):
   572	            map_layer_to_kicad("Unknown.Layer")
   573	
   574	    def test_layer_mapping_completeness(self) -> None:
   575	        """SPEC_TO_KICAD_LAYER should contain all expected mappings."""
   576	        expected_mappings = {
   577	            "L1": "F.Cu",
   578	            "L2": "In1.Cu",
   579	            "L3": "In2.Cu",
   580	            "L4": "B.Cu",
   581	            "F.Cu": "F.Cu",
   582	            "In1.Cu": "In1.Cu",
   583	            "In2.Cu": "In2.Cu",
   584	            "B.Cu": "B.Cu",
   585	        }
   586	        assert SPEC_TO_KICAD_LAYER == expected_mappings
   587	
   588	
   589	class TestBoardFileValidation:
   590	    """Tests for validating generated .kicad_pcb files are syntactically correct."""
   591	
   592	    def test_board_file_not_empty(self, f0_spec: CouponSpec, tmp_path: Path) -> None:
   593	        """Generated board file should not be empty."""
   594	        resolved = resolve(f0_spec)
   595	        board_path = write_board(f0_spec, resolved, tmp_path)
   596	
   597	        content = board_path.read_text(encoding="utf-8")
   598	        assert len(content) > 0, "Board file should not be empty"
   599	
   600	    def test_board_file_starts_with_kicad_pcb(self, f0_spec: CouponSpec, tmp_path: Path) -> None:
   601	        """Generated board file should start with (kicad_pcb."""
   602	        resolved = resolve(f0_spec)
   603	        board_path = write_board(f0_spec, resolved, tmp_path)
   604	
   605	        content = board_path.read_text(encoding="utf-8")
   606	        assert content.strip().startswith("(kicad_pcb"), (
   607	            f"Board file should start with (kicad_pcb, got: {content[:50]!r}"
   608	        )
   609	
   610	    def test_board_file_balanced_parentheses(self, f0_spec: CouponSpec, tmp_path: Path) -> None:
   611	        """Generated board file should have balanced parentheses."""
   612	        resolved = resolve(f0_spec)
   613	        board_path = write_board(f0_spec, resolved, tmp_path)
   614	
   615	        content = board_path.read_text(encoding="utf-8")
   616	        open_count = content.count("(")
   617	        close_count = content.count(")")
   618	        assert open_count == close_count, (
   619	            f"Unbalanced parentheses: {open_count} open vs {close_count} close"
   620	        )
   621	
   622	    def test_board_file_parseable(self, f0_spec: CouponSpec, tmp_path: Path) -> None:
   623	        """Generated board file should parse without errors."""
   624	        resolved = resolve(f0_spec)
   625	        board_path = write_board(f0_spec, resolved, tmp_path)
   626	
   627	        content = board_path.read_text(encoding="utf-8")
   628	        # This should not raise
   629	        parsed = parse(content)
   630	        assert parsed[0] == "kicad_pcb"
   631	
   632	    def test_f1_board_file_valid(self, f1_spec: CouponSpec, tmp_path: Path) -> None:
   633	        """F1 generated board file should be syntactically valid."""
   634	        resolved = resolve(f1_spec)
   635	        board_path = write_board(f1_spec, resolved, tmp_path)
   636	
   637	        content = board_path.read_text(encoding="utf-8")
   638	
   639	        # Check basic validity
   640	        assert content.strip().startswith("(kicad_pcb")
   641	        assert content.count("(") == content.count(")")
   642	
   643	        # Should parse without error
   644	        parsed = parse(content)
   645	        assert parsed[0] == "kicad_pcb"
   646	
   647	
   648	@pytest.fixture
   649	def f1_spec_with_logical_layers(f1_spec_data: dict) -> CouponSpec:
   650	    """F1 spec using logical layer names (L2, L3) for antipads."""
   651	    spec = f1_spec_data.copy()
   652	    spec["discontinuity"] = {
   653	        "type": "VIA_TRANSITION",
   654	        "signal_via": {
   655	            "drill_nm": 300000,
   656	            "diameter_nm": 650000,
   657	            "pad_diameter_nm": 900000,
   658	        },
   659	        "antipads": {
   660	            "L2": {
   661	                "shape": "CIRCLE",
   662	                "r_nm": 480000,
   663	            },
   664	            "L3": {
   665	                "shape": "CIRCLE",
   666	                "r_nm": 480000,
   667	            },
   668	        },
   669	        "return_vias": {
   670	            "pattern": "RING",
   671	            "count": 4,
   672	            "radius_nm": 1000000,
   673	            "via": {"drill_nm": 300000, "diameter_nm": 510000},
   674	        },
   675	        "plane_cutouts": {},
   676	    }
   677	    return CouponSpec.model_validate(spec)
   678	
   679	
   680	class TestLayerMappingIntegration:
   681	    """Integration tests verifying layer mapping works in board generation."""
   682	
   683	    def test_f1_logical_layers_mapped_to_kicad(
   684	        self, f1_spec_with_logical_layers: CouponSpec, tmp_path: Path
   685	    ) -> None:
   686	        """F1 spec with L2/L3 layers should generate board with In1.Cu/In2.Cu."""
   687	        resolved = resolve(f1_spec_with_logical_layers)
   688	        board_path = write_board(f1_spec_with_logical_layers, resolved, tmp_path)
   689	
   690	        content = board_path.read_text(encoding="utf-8")
   691	
   692	        # Should NOT contain the logical layer names L2/L3 (except in comments)
   693	        # Split lines and check non-comment lines
   694	        for line in content.split("\n"):
   695	            # Skip comment-like patterns
   696	            if line.strip().startswith(";"):
   697	                continue
   698	            # Check that L2 and L3 are not used as layer names
   699	            # (layer L2) or (layer L3) should not appear
   700	            assert "(layer\n      L2)" not in line and "(layer L2)" not in line, (
   701	                f"Found invalid layer name L2 in: {line}"
   702	            )
   703	            assert "(layer\n      L3)" not in line and "(layer L3)" not in line, (
   704	                f"Found invalid layer name L3 in: {line}"
   705	            )
   706	
   707	        # Should contain the correct KiCad layer names
   708	        assert "In1.Cu" in content, "Should contain In1.Cu layer"
   709	        assert "In2.Cu" in content, "Should contain In2.Cu layer"
   710	
   711	    def test_f1_logical_layers_zones_have_valid_kicad_layers(
   712	        self, f1_spec_with_logical_layers: CouponSpec
   713	    ) -> None:
   714	        """Zone elements should have valid KiCad layer names."""
   715	        resolved = resolve(f1_spec_with_logical_layers)
   716	        writer = BoardWriter(f1_spec_with_logical_layers, resolved)
   717	        board = writer.build_board()
   718	
   719	        # Find zone elements
   720	        zones = [e for e in board if isinstance(e, list) and e[0] == "zone"]
   721	        assert len(zones) >= 2, "Should have at least 2 zones for antipads"
   722	
   723	        valid_kicad_layers = {"F.Cu", "In1.Cu", "In2.Cu", "B.Cu"}
   724	
   725	        for zone in zones:
   726	            # Find the layer element in the zone
   727	            layer_elems = [e for e in zone if isinstance(e, list) and e[0] == "layer"]
   728	            assert len(layer_elems) == 1, "Each zone should have exactly one layer element"
   729	
   730	            layer_name = layer_elems[0][1]
   731	            assert layer_name in valid_kicad_layers, (
   732	                f"Zone has invalid layer name: {layer_name!r}, "
   733	                f"expected one of {valid_kicad_layers}"
   734	            )
   735	
   736	    def test_board_file_kicad_loadable_layers(
   737	        self, f1_spec_with_logical_layers: CouponSpec, tmp_path: Path
   738	    ) -> None:
   739	        """Generated board file should only use valid KiCad layer names.
   740	
   741	        This is a regression test for the issue where L2/L3 logical layer
   742	        names were being written to the board file, causing KiCad to fail
   743	        to load the file (returncode 3: "Failed to load board").
   744	        """
   745	        resolved = resolve(f1_spec_with_logical_layers)
   746	        board_path = write_board(f1_spec_with_logical_layers, resolved, tmp_path)
   747	
   748	        content = board_path.read_text(encoding="utf-8")
   749	        parsed = parse(content)
   750	
   751	        # Valid copper layer names in KiCad for 4-layer boards
   752	        valid_copper_layers = {"F.Cu", "In1.Cu", "In2.Cu", "B.Cu"}
   753	
   754	        # Find all zones and check their layer names
   755	        def find_zones(sexpr: list) -> list:
   756	            zones = []
   757	            for elem in sexpr:
   758	                if isinstance(elem, list):
   759	                    if elem and elem[0] == "zone":
   760	                        zones.append(elem)
   761	                    zones.extend(find_zones(elem))
   762	            return zones
   763	
   764	        zones = find_zones(parsed)
   765	        for zone in zones:
   766	            for elem in zone:
   767	                if isinstance(elem, list) and elem[0] == "layer":
   768	                    layer_name = elem[1]
   769	                    assert layer_name in valid_copper_layers, (
   770	                        f"Zone uses invalid layer name '{layer_name}'. "
   771	                        f"This would cause KiCad to fail with 'Failed to load board'. "
   772	                        f"Valid layers: {valid_copper_layers}"
   773	                    )
   774	
   775	
   776	class TestAntipadKeeoutRules:
   777	    """Regression tests for antipad/cutout keepout rules.
   778	
   779	    These tests verify that antipad and cutout zones only block copperpour
   780	    and allow vias/tracks/pads to pass through. This prevents DRC errors
   781	    like 'items_not_allowed' when the signal via passes through antipads.
   782	    """
   783	
   784	    def test_antipad_allows_vias(self, f1_spec: CouponSpec) -> None:
   785	        """Antipad zones must allow vias to pass through.
   786	
   787	        Regression test: antipads blocking vias caused 'items_not_allowed'
   788	        DRC errors because the signal via passes through antipad regions.
   789	        """
   790	        resolved = resolve(f1_spec)
   791	        writer = BoardWriter(f1_spec, resolved)
   792	        board = writer.build_board()
   793	
   794	        # Find zone elements (antipads/cutouts)
   795	        zones = [e for e in board if isinstance(e, list) and e[0] == "zone"]
   796	
   797	        for zone in zones:
   798	            # Find the keepout element
   799	            keepout_elems = [e for e in zone if isinstance(e, list) and e[0] == "keepout"]
   800	            assert len(keepout_elems) == 1, "Each zone should have exactly one keepout element"
   801	
   802	            keepout = keepout_elems[0]
   803	
   804	            # Find vias rule
   805	            vias_rules = [e for e in keepout if isinstance(e, list) and e[0] == "vias"]
   806	            assert len(vias_rules) == 1, "Keepout should have exactly one vias rule"
   807	
   808	            vias_rule = vias_rules[0][1]
   809	            assert vias_rule == "allowed", (
   810	                f"Antipad/cutout must allow vias (got '{vias_rule}'). "
   811	                f"Blocking vias causes 'items_not_allowed' DRC errors."
   812	            )
   813	
   814	    def test_antipad_blocks_copperpour(self, f1_spec: CouponSpec) -> None:
   815	        """Antipad zones must block copperpour to create clearance in ground planes."""
   816	        resolved = resolve(f1_spec)
   817	        writer = BoardWriter(f1_spec, resolved)
   818	        board = writer.build_board()
   819	
   820	        zones = [e for e in board if isinstance(e, list) and e[0] == "zone"]
   821	
   822	        for zone in zones:
   823	            keepout_elems = [e for e in zone if isinstance(e, list) and e[0] == "keepout"]
   824	            assert len(keepout_elems) == 1
   825	
   826	            keepout = keepout_elems[0]
   827	
   828	            # Find copperpour rule
   829	            copperpour_rules = [e for e in keepout if isinstance(e, list) and e[0] == "copperpour"]
   830	            assert len(copperpour_rules) == 1, "Keepout should have exactly one copperpour rule"
   831	
   832	            copperpour_rule = copperpour_rules[0][1]
   833	            assert copperpour_rule == "not_allowed", (
   834	                f"Antipad/cutout must block copperpour (got '{copperpour_rule}'). "
   835	                f"This creates the clearance in ground planes."
   836	            )
   837	
   838	    def test_antipad_allows_tracks_and_pads(self, f1_spec: CouponSpec) -> None:
   839	        """Antipad zones should allow tracks and pads."""
   840	        resolved = resolve(f1_spec)
   841	        writer = BoardWriter(f1_spec, resolved)
   842	        board = writer.build_board()
   843	
   844	        zones = [e for e in board if isinstance(e, list) and e[0] == "zone"]
   845	
   846	        for zone in zones:
   847	            keepout_elems = [e for e in zone if isinstance(e, list) and e[0] == "keepout"]
   848	            assert len(keepout_elems) == 1
   849	
   850	            keepout = keepout_elems[0]
   851	
   852	            # Check tracks rule
   853	            tracks_rules = [e for e in keepout if isinstance(e, list) and e[0] == "tracks"]
   854	            assert len(tracks_rules) == 1
   855	            assert tracks_rules[0][1] == "allowed", "Antipad should allow tracks"
   856	
   857	            # Check pads rule
   858	            pads_rules = [e for e in keepout if isinstance(e, list) and e[0] == "pads"]
   859	            assert len(pads_rules) == 1
   860	            assert pads_rules[0][1] == "allowed", "Antipad should allow pads"
   861	
   862	
   863	class TestReturnViasNetAssignment:
   864	    """Regression tests for return via net assignment.
   865	
   866	    These tests verify that return vias are assigned to net 0 (unconnected)
   867	    in M1 test coupons. This prevents DRC 'unconnected_items' errors since
   868	    there are no ground plane fills to provide copper connectivity.
   869	    """
   870	
   871	    def test_return_vias_on_gnd_net(self, f1_spec_with_antipads: CouponSpec) -> None:
   872	        """Return vias must be on GND net (net 2) with proper connectivity.
   873	
   874	        Return vias are connected to GND (net 2) via ground ring traces
   875	        that form a ring connecting all return vias on F.Cu and B.Cu layers.
   876	        This ensures proper DRC compliance with no via_dangling or
   877	        unconnected_items violations.
   878	        """
   879	        resolved = resolve(f1_spec_with_antipads)
   880	        writer = BoardWriter(f1_spec_with_antipads, resolved)
   881	        board = writer.build_board()
   882	
   883	        # Find via elements
   884	        vias = [e for e in board if isinstance(e, list) and e[0] == "via"]
   885	        assert len(vias) >= 2, "F1 board should have signal + return vias"
   886	
   887	        # Count how many vias are on net 2 (GND/return vias) vs net 1 (signal via)
   888	        net_2_count = 0
   889	        net_1_count = 0
   890	
   891	        for via in vias:
   892	            net_elems = [e for e in via if isinstance(e, list) and e[0] == "net"]
   893	            assert len(net_elems) == 1, "Each via should have exactly one net element"
   894	            net_id = net_elems[0][1]
   895	
   896	            if net_id == 2:
   897	                net_2_count += 1
   898	            elif net_id == 1:
   899	                net_1_count += 1
   900	
   901	        # Should have exactly 1 signal via on net 1 and all others on net 2 (GND)
   902	        assert net_1_count == 1, f"Should have exactly 1 signal via on net 1, got {net_1_count}"
   903	        assert net_2_count >= 1, (
   904	            f"Return vias should be on net 2 (GND), "
   905	            f"but found {net_2_count} vias on net 2. "
   906	            f"Return vias are connected via ground ring traces."
   907	        )
   908	
   909	    def test_signal_via_on_signal_net(self, f1_spec_with_antipads: CouponSpec) -> None:
   910	        """Signal via should be on signal net (net 1)."""
   911	        resolved = resolve(f1_spec_with_antipads)
   912	        writer = BoardWriter(f1_spec_with_antipads, resolved)
   913	        board = writer.build_board()
   914	
   915	        vias = [e for e in board if isinstance(e, list) and e[0] == "via"]
   916	
   917	        # Count vias on each net
   918	        signal_via_found = False
   919	        for via in vias:
   920	            net_elems = [e for e in via if isinstance(e, list) and e[0] == "net"]
   921	            assert len(net_elems) == 1
   922	            net_id = net_elems[0][1]
   923	
   924	            if net_id == 1:
   925	                signal_via_found = True
   926	
   927	        assert signal_via_found, "F1 board should have a signal via on net 1"

================================================================================
FILE: src/formula_foundry/coupongen/kicad/board_writer.py
================================================================================
     1	"""KiCad board writer with deterministic S-expression generation.
     2	
     3	This module implements headless .kicad_pcb file generation using the S-expression
     4	format. It satisfies the IKiCadBackend interface and provides deterministic output
     5	through UUIDv5-based tstamp generation.
     6	
     7	Key features:
     8	- Deterministic UUIDv5 generation for all tstamp/uuid fields
     9	- S-expression output using the sexpr module
    10	- Support for F0 (calibration) and F1 (via transition) coupon families
    11	- Integer nanometer coordinate system with mm conversion for output
    12	- F1 antipads/cutouts and return vias with configurable patterns
    13	- All geometry consumed from LayoutPlan (single source of truth per CP-2.6)
    14	
    15	Satisfies REQ-M1-007, REQ-M1-012, REQ-M1-013 and CP-2.6 (ECO-M1-ALIGN-0001).
    16	"""
    17	
    18	from __future__ import annotations
    19	
    20	import math
    21	import uuid
    22	from pathlib import Path
    23	from typing import TYPE_CHECKING
    24	
    25	from ..builders.f1_builder import F1CouponComposition, build_f1_coupon
    26	from ..constraints.core import resolve_fab_limits
    27	from ..families import FAMILY_F1
    28	from ..geom.layout import LayoutPlan
    29	from ..resolve import ResolvedDesign
    30	from ..spec import CouponSpec
    31	from . import sexpr
    32	from .sexpr import SExprList, nm_to_mm
    33	
    34	if TYPE_CHECKING:
    35	    pass
    36	
    37	# UUIDv5 namespace for coupongen deterministic IDs
    38	_UUID_NAMESPACE = uuid.uuid5(uuid.NAMESPACE_URL, "coupongen")
    39	
    40	# KiCad version constants
    41	KICAD_FILE_VERSION = 20240101
    42	KICAD_GENERATOR = "coupongen"
    43	
    44	# Default layer definitions for 4-layer board
    45	DEFAULT_LAYER_DEFS: tuple[tuple[int, str, str], ...] = (
    46	    (0, "F.Cu", "signal"),
    47	    (1, "In1.Cu", "signal"),
    48	    (2, "In2.Cu", "signal"),
    49	    (31, "B.Cu", "signal"),
    50	    (32, "B.Adhes", "user"),
    51	    (33, "F.Adhes", "user"),
    52	    (34, "B.Paste", "user"),
    53	    (35, "F.Paste", "user"),
    54	    (36, "B.SilkS", "user"),
    55	    (37, "F.SilkS", "user"),
    56	    (38, "B.Mask", "user"),
    57	    (39, "F.Mask", "user"),
    58	    (40, "Dwgs.User", "user"),
    59	    (41, "Cmts.User", "user"),
    60	    (42, "Eco1.User", "user"),
    61	    (43, "Eco2.User", "user"),
    62	    (44, "Edge.Cuts", "user"),
    63	    (45, "Margin", "user"),
    64	    (46, "B.CrtYd", "user"),
    65	    (47, "F.CrtYd", "user"),
    66	    (48, "B.Fab", "user"),
    67	    (49, "F.Fab", "user"),
    68	)
    69	
    70	# Mapping from spec layer names to KiCad layer names (4-layer board)
    71	# The spec uses logical names (L1, L2, L3, L4) while KiCad uses physical names
    72	SPEC_TO_KICAD_LAYER: dict[str, str] = {
    73	    "L1": "F.Cu",
    74	    "L2": "In1.Cu",
    75	    "L3": "In2.Cu",
    76	    "L4": "B.Cu",
    77	    # Pass through KiCad layer names unchanged
    78	    "F.Cu": "F.Cu",
    79	    "In1.Cu": "In1.Cu",
    80	    "In2.Cu": "In2.Cu",
    81	    "B.Cu": "B.Cu",
    82	}
    83	
    84	
    85	def map_layer_to_kicad(spec_layer: str) -> str:
    86	    """Map a spec layer name to a KiCad layer name.
    87	
    88	    Args:
    89	        spec_layer: Layer name from spec (e.g., "L2") or KiCad name (e.g., "In1.Cu").
    90	
    91	    Returns:
    92	        KiCad layer name (e.g., "In1.Cu").
    93	
    94	    Raises:
    95	        ValueError: If the layer name is not recognized.
    96	    """
    97	    if spec_layer in SPEC_TO_KICAD_LAYER:
    98	        return SPEC_TO_KICAD_LAYER[spec_layer]
    99	    raise ValueError(
   100	        f"Unknown layer name: {spec_layer!r}. "
   101	        f"Expected one of: {sorted(SPEC_TO_KICAD_LAYER.keys())}"
   102	    )
   103	
   104	
   105	def deterministic_uuid(schema_version: int, path: str) -> str:
   106	    """Generate a deterministic UUIDv5 for a given path.
   107	
   108	    The UUID is generated using a two-level namespace:
   109	    1. Base namespace derived from "coupongen" URL
   110	    2. Version-specific namespace derived from schema version
   111	
   112	    This ensures that:
   113	    - Same spec version + same path = same UUID
   114	    - Different spec versions produce different UUIDs
   115	
   116	    Args:
   117	        schema_version: CouponSpec schema version.
   118	        path: Hierarchical path identifying the element (e.g., "board.outline").
   119	
   120	    Returns:
   121	        UUID string in standard format.
   122	    """
   123	    version_namespace = uuid.uuid5(_UUID_NAMESPACE, f"schema:{schema_version}")
   124	    return str(uuid.uuid5(version_namespace, path))
   125	
   126	
   127	def deterministic_uuid_indexed(schema_version: int, path: str, index: int) -> str:
   128	    """Generate a deterministic UUIDv5 for an indexed element.
   129	
   130	    Args:
   131	        schema_version: CouponSpec schema version.
   132	        path: Base path for the element type.
   133	        index: Element index.
   134	
   135	    Returns:
   136	        UUID string in standard format.
   137	    """
   138	    return deterministic_uuid(schema_version, f"{path}[{index}]")
   139	
   140	
   141	class BoardWriter:
   142	    """KiCad board file writer with deterministic output.
   143	
   144	    This class generates .kicad_pcb files from CouponSpec and ResolvedDesign
   145	    using the S-expression format. All UUIDs/timestamps are deterministically
   146	    generated from the spec content.
   147	
   148	    All geometry (track endpoints, via positions, footprint placements) is
   149	    consumed from the LayoutPlan in ResolvedDesign, which is the single source
   150	    of truth for geometry (CP-2.6). No duplicate geometry math is performed.
   151	
   152	    For F1 coupons, this class uses the F1 builder composition to correctly
   153	    generate antipads/cutouts with configurable return via patterns.
   154	    """
   155	
   156	    def __init__(self, spec: CouponSpec, resolved: ResolvedDesign) -> None:
   157	        """Initialize the board writer.
   158	
   159	        Args:
   160	            spec: Coupon specification.
   161	            resolved: Resolved design parameters with computed LayoutPlan.
   162	
   163	        Raises:
   164	            ValueError: If resolved.layout_plan is None.
   165	        """
   166	        self.spec = spec
   167	        self.resolved = resolved
   168	        self._uuid_counter = 0
   169	
   170	        # Get LayoutPlan from ResolvedDesign - this is the single source of
   171	        # truth for all geometry (CP-2.6)
   172	        layout_plan = resolved.layout_plan
   173	        if layout_plan is None:
   174	            raise ValueError(
   175	                "ResolvedDesign.layout_plan is None. The resolver must compute "
   176	                "a LayoutPlan before passing to BoardWriter."
   177	            )
   178	        self._layout_plan: LayoutPlan = layout_plan
   179	
   180	        # Build F1 composition if applicable (still needed for antipads/cutouts)
   181	        self._f1_composition: F1CouponComposition | None = None
   182	        if spec.coupon_family == FAMILY_F1:
   183	            self._f1_composition = build_f1_coupon(spec, resolved)
   184	
   185	    def _next_uuid(self, path: str) -> str:
   186	        """Generate the next deterministic UUID for a path."""
   187	        return deterministic_uuid(self.spec.schema_version, path)
   188	
   189	    def _indexed_uuid(self, base_path: str, index: int) -> str:
   190	        """Generate a deterministic UUID for an indexed element."""
   191	        return deterministic_uuid_indexed(self.spec.schema_version, base_path, index)
   192	
   193	    def build_board(self) -> SExprList:
   194	        """Build the complete board S-expression.
   195	
   196	        Returns:
   197	            S-expression list representing the full .kicad_pcb file.
   198	        """
   199	        elements: SExprList = [
   200	            "kicad_pcb",
   201	            ["version", KICAD_FILE_VERSION],
   202	            ["generator", KICAD_GENERATOR],
   203	        ]
   204	
   205	        # Add header sections
   206	        elements.append(self._build_general())
   207	        elements.append(self._build_paper())
   208	        elements.append(self._build_layers())
   209	        elements.append(self._build_setup())
   210	
   211	        # Add net declarations and net classes (design rules)
   212	        elements.extend(self._build_nets())
   213	        elements.extend(self._build_net_classes())
   214	
   215	        # Add board outline
   216	        elements.extend(self._build_outline())
   217	
   218	        # Add footprints (connectors)
   219	        elements.extend(self._build_footprints())
   220	
   221	        # Add tracks (transmission lines)
   222	        elements.extend(self._build_tracks())
   223	
   224	        # Add vias if discontinuity present
   225	        if self.spec.discontinuity is not None:
   226	            elements.extend(self._build_vias())
   227	
   228	        # Add antipads and cutouts for F1 coupons
   229	        if self._f1_composition is not None:
   230	            elements.extend(self._build_antipads())
   231	            elements.extend(self._build_cutouts())
   232	
   233	        # Add ground plane fills for return via connectivity (F1 coupons)
   234	        if self.spec.discontinuity is not None and self.spec.discontinuity.return_vias is not None:
   235	            elements.extend(self._build_ground_planes())
   236	
   237	        return elements
   238	
   239	    def _build_general(self) -> SExprList:
   240	        """Build the general section."""
   241	        return ["general", ["thickness", 1.6]]
   242	
   243	    def _build_paper(self) -> SExprList:
   244	        """Build the paper size declaration."""
   245	        return ["paper", "A4"]
   246	
   247	    def _build_layers(self) -> SExprList:
   248	        """Build the layers section based on stackup."""
   249	        result: SExprList = ["layers"]
   250	        for layer_id, name, layer_type in DEFAULT_LAYER_DEFS:
   251	            result.append([layer_id, name, layer_type])
   252	        return result
   253	
   254	    def _build_setup(self) -> SExprList:
   255	        """Build the setup section with design rules from fab profile.
   256	
   257	        Configures KiCad design rules based on the fab profile limits:
   258	        - min_via_diameter: minimum via pad diameter
   259	        - min_via_drill: minimum via hole size
   260	        - min_track_width: minimum trace width
   261	        - min_clearance: minimum copper-to-copper clearance
   262	
   263	        These are specified in the default netclass to set board-wide design rules.
   264	        """
   265	        # Get resolved fab limits using the standard constraint resolution
   266	        try:
   267	            limits = resolve_fab_limits(self.spec)
   268	            # Convert from nm to mm
   269	            min_via_dia = nm_to_mm(limits.get("min_via_diameter_nm", 200000))
   270	            min_via_drill = nm_to_mm(limits.get("min_drill_nm", 200000))
   271	            min_track = nm_to_mm(limits.get("min_trace_width_nm", 100000))
   272	            min_clearance = nm_to_mm(limits.get("min_gap_nm", 100000))
   273	        except Exception:
   274	            # Default to generous limits that won't cause DRC failures
   275	            min_via_dia = 0.2
   276	            min_via_drill = 0.2
   277	            min_track = 0.1
   278	            min_clearance = 0.1
   279	
   280	        return [
   281	            "setup",
   282	            ["pad_to_mask_clearance", 0],
   283	            ["allow_soldermask_bridges_in_footprints", "no"],
   284	            [
   285	                "pcbplotparams",
   286	                ["layerselection", "0x00010fc_ffffffff"],
   287	                ["plot_on_all_layers_selection", "0x0000000_00000000"],
   288	                ["disableapertmacros", "false"],
   289	                ["usegerberextensions", "false"],
   290	                ["usegerberattributes", "true"],
   291	                ["usegerberadvancedattributes", "true"],
   292	                ["creategerberjobfile", "true"],
   293	                ["svguseinch", "false"],
   294	                ["svgprecision", 4],
   295	                ["excludeedgelayer", "true"],
   296	                ["plotframeref", "false"],
   297	                ["viasonmask", "false"],
   298	                ["mode", 1],
   299	                ["useauxorigin", "false"],
   300	                ["hpglpennumber", 1],
   301	                ["hpglpenspeed", 20],
   302	                ["hpglpendiameter", 15.000000],
   303	                ["pdf_front_fp_property_popups", "true"],
   304	                ["pdf_back_fp_property_popups", "true"],
   305	                ["dxfpolygonmode", "true"],
   306	                ["dxfimperialunits", "true"],
   307	                ["dxfusepcbnewfont", "true"],
   308	                ["psnegative", "false"],
   309	                ["psa4output", "false"],
   310	                ["plotreference", "true"],
   311	                ["plotvalue", "true"],
   312	                ["plotfptext", "true"],
   313	                ["plotinvisibletext", "false"],
   314	                ["sketchpadsonfab", "false"],
   315	                ["subtractmaskfromsilk", "false"],
   316	                ["outputformat", 1],
   317	                ["mirror", "false"],
   318	                ["drillshape", 1],
   319	                ["scaleselection", 1],
   320	                ["outputdirectory", ""],
   321	            ],
   322	        ]
   323	
   324	    def _build_net_classes(self) -> list[SExprList]:
   325	        """Build net class definitions with design rules from fab profile.
   326	
   327	        The Default net class sets the board-wide minimum design rules.
   328	        """
   329	        # Get resolved fab limits
   330	        try:
   331	            limits = resolve_fab_limits(self.spec)
   332	            min_clearance = nm_to_mm(limits.get("min_gap_nm", 100000))
   333	            min_track = nm_to_mm(limits.get("min_trace_width_nm", 100000))
   334	            min_via_dia = nm_to_mm(limits.get("min_via_diameter_nm", 200000))
   335	            min_via_drill = nm_to_mm(limits.get("min_drill_nm", 200000))
   336	        except Exception:
   337	            min_clearance = 0.1
   338	            min_track = 0.1
   339	            min_via_dia = 0.2
   340	            min_via_drill = 0.2
   341	
   342	        return [
   343	            [
   344	                "net_class",
   345	                "Default",
   346	                "",
   347	                ["clearance", min_clearance],
   348	                ["trace_width", min_track],
   349	                ["via_dia", min_via_dia],
   350	                ["via_drill", min_via_drill],
   351	                ["uvia_dia", min_via_dia],
   352	                ["uvia_drill", min_via_drill],
   353	            ]
   354	        ]
   355	
   356	    def _build_nets(self) -> list[SExprList]:
   357	        """Build net declarations."""
   358	        return [
   359	            ["net", 0, ""],
   360	            ["net", 1, "SIG"],
   361	            ["net", 2, "GND"],
   362	        ]
   363	
   364	    def _build_outline(self) -> list[SExprList]:
   365	        """Build board outline as gr_rect on Edge.Cuts layer.
   366	
   367	        Uses LayoutPlan as the single source of truth for board dimensions
   368	        (CP-2.6). The board dimensions and edge coordinates are read directly
   369	        from the LayoutPlan.
   370	        """
   371	        # Get board dimensions from LayoutPlan (single source of truth)
   372	        lp = self._layout_plan
   373	        y_top = lp.y_board_top_edge_nm
   374	        y_bottom = lp.y_board_bottom_edge_nm
   375	        x_left = lp.x_board_left_edge_nm
   376	        x_right = lp.x_board_right_edge_nm
   377	
   378	        outline_uuid = self._next_uuid("board.outline")
   379	
   380	        return [
   381	            [
   382	                "gr_rect",
   383	                ["start", nm_to_mm(x_left), nm_to_mm(y_bottom)],
   384	                ["end", nm_to_mm(x_right), nm_to_mm(y_top)],
   385	                ["layer", "Edge.Cuts"],
   386	                ["width", 0.1],
   387	                ["tstamp", outline_uuid],
   388	            ]
   389	        ]
   390	
   391	    def _build_footprints(self) -> list[SExprList]:
   392	        """Build footprint instances for connectors with inline pad definitions.
   393	
   394	        Uses LayoutPlan port positions as the single source of truth for
   395	        connector placement (CP-2.6). The footprint reference position and
   396	        rotation are read from the LayoutPlan's left_port and right_port.
   397	
   398	        Footprints include inline pad definitions so that:
   399	        1. No external footprint library is required
   400	        2. Tracks can properly connect to the signal pad
   401	        3. DRC does not report dangling tracks or missing library errors
   402	
   403	        The signal pad is positioned at the signal_pad_x_nm, signal_pad_y_nm
   404	        coordinates from the LayoutPlan, converted to footprint-local coordinates.
   405	
   406	        The pad layer is determined from the connecting segment's layer, which
   407	        ensures proper connectivity for via transition coupons where left and
   408	        right traces may be on different layers.
   409	        """
   410	        footprints: list[SExprList] = []
   411	        lp = self._layout_plan
   412	
   413	        # Get trace width from spec for pad sizing
   414	        trace_width_nm = int(self.spec.transmission_line.w_nm)
   415	
   416	        # Determine the layer for each side based on connecting segments
   417	        # For F0: both segments on same layer
   418	        # For F1: left segment on entry layer, right segment on exit layer
   419	        segment_layers_by_side = {}
   420	        for seg in lp.segments:
   421	            if seg.label == "left":
   422	                segment_layers_by_side["left"] = seg.layer
   423	            elif seg.label == "right":
   424	                segment_layers_by_side["right"] = seg.layer
   425	
   426	        # Map side to port plan
   427	        port_plans = {
   428	            "left": lp.left_port,
   429	            "right": lp.right_port,
   430	        }
   431	
   432	        for side, port in port_plans.items():
   433	            uuid_value = self._next_uuid(f"connector.{side}")
   434	            pad_uuid = self._next_uuid(f"connector.{side}.pad1")
   435	
   436	            # Use port reference position from LayoutPlan
   437	            x_nm = port.x_ref_nm
   438	            y_nm = port.y_ref_nm
   439	            # Convert rotation from millidegrees to degrees for KiCad
   440	            rotation_deg = port.rotation_mdeg // 1000
   441	
   442	            # Determine layer from connecting segment
   443	            pad_layer = segment_layers_by_side.get(side, "F.Cu")
   444	
   445	            # Calculate local pad position relative to footprint reference
   446	            # For rotated footprints, we need to transform the signal pad position
   447	            local_pad_x_nm = port.signal_pad_x_nm - x_nm
   448	            local_pad_y_nm = port.signal_pad_y_nm - y_nm
   449	
   450	            # If rotated 180 degrees, negate the local offset
   451	            if rotation_deg == 180:
   452	                local_pad_x_nm = -local_pad_x_nm
   453	                local_pad_y_nm = -local_pad_y_nm
   454	
   455	            # Pad size: use trace width for both dimensions (square pad)
   456	            # This ensures the track connects cleanly
   457	            pad_size_nm = trace_width_nm
   458	
   459	            # Build signal pad element
   460	            # Use short library-less footprint name to avoid library lookup issues
   461	            fp_name = port.footprint.split(":")[-1] if ":" in port.footprint else port.footprint
   462	
   463	            pad: SExprList = [
   464	                "pad",
   465	                "1",
   466	                "smd",
   467	                "rect",
   468	                ["at", nm_to_mm(local_pad_x_nm), nm_to_mm(local_pad_y_nm)],
   469	                ["size", nm_to_mm(pad_size_nm), nm_to_mm(pad_size_nm)],
   470	                ["layers", pad_layer],
   471	                ["net", 1, "SIG"],
   472	                ["uuid", pad_uuid],
   473	            ]
   474	
   475	            fp: SExprList = [
   476	                "footprint",
   477	                fp_name,
   478	                ["layer", pad_layer],
   479	                ["at", nm_to_mm(x_nm), nm_to_mm(y_nm), rotation_deg],
   480	                ["tstamp", uuid_value],
   481	                pad,
   482	            ]
   483	            footprints.append(fp)
   484	
   485	        return footprints
   486	
   487	    def _build_tracks(self) -> list[SExprList]:
   488	        """Build track segments for transmission lines.
   489	
   490	        Uses LayoutPlan segments as the single source of truth for track
   491	        endpoints (CP-2.6). All segment positions, widths, and layers are
   492	        read from the LayoutPlan's segment definitions.
   493	
   494	        This eliminates duplicate geometry math - the LayoutPlan already
   495	        has computed the correct segment endpoints ensuring topological
   496	        continuity (e.g., left segment end == discontinuity == right segment start).
   497	        """
   498	        tracks: list[SExprList] = []
   499	        lp = self._layout_plan
   500	
   501	        # Iterate over all segments in the LayoutPlan
   502	        for segment in lp.segments:
   503	            track_uuid = self._next_uuid(f"track.{segment.label}")
   504	
   505	            # Net ID: SIG net is 1
   506	            net_id = 1 if segment.net_name == "SIG" else 0
   507	
   508	            tracks.append(
   509	                [
   510	                    "segment",
   511	                    ["start", nm_to_mm(segment.x_start_nm), nm_to_mm(segment.y_nm)],
   512	                    ["end", nm_to_mm(segment.x_end_nm), nm_to_mm(segment.y_nm)],
   513	                    ["width", nm_to_mm(segment.width_nm)],
   514	                    ["layer", segment.layer],
   515	                    ["net", net_id],
   516	                    ["tstamp", track_uuid],
   517	                ]
   518	            )
   519	
   520	        return tracks
   521	
   522	    def _build_vias(self) -> list[SExprList]:
   523	        """Build via elements for discontinuity.
   524	
   525	        Uses LayoutPlan's x_disc_nm as the single source of truth for the
   526	        discontinuity center X position (CP-2.6). The Y position is taken
   527	        from the LayoutPlan's y_centerline_nm.
   528	
   529	        For F1 coupons, the F1 builder composition is still used for return
   530	        via positions and antipad/cutout geometry, but the signal via position
   531	        comes from the LayoutPlan.
   532	        """
   533	        vias: list[SExprList] = []
   534	        lp = self._layout_plan
   535	        disc = self.spec.discontinuity
   536	
   537	        if disc is None or not lp.has_discontinuity:
   538	            return vias
   539	
   540	        # Get discontinuity position from LayoutPlan (single source of truth)
   541	        center_x = lp.x_disc_nm
   542	        assert center_x is not None  # Checked by has_discontinuity
   543	        center_y = lp.y_centerline_nm
   544	
   545	        signal_via_uuid = self._next_uuid("via.signal")
   546	
   547	        vias.append(
   548	            [
   549	                "via",
   550	                ["at", nm_to_mm(center_x), nm_to_mm(center_y)],
   551	                ["size", nm_to_mm(int(disc.signal_via.diameter_nm))],
   552	                ["drill", nm_to_mm(int(disc.signal_via.drill_nm))],
   553	                ["layers", "F.Cu", "B.Cu"],
   554	                ["net", 1],
   555	                ["tstamp", signal_via_uuid],
   556	            ]
   557	        )
   558	
   559	        # Return vias if present - use F1 composition for correct positioning
   560	        # (the F1 builder uses the same discontinuity position internally)
   561	        # Return vias are on GND net (net 2) and connect to ground plane fills
   562	        # on F.Cu and B.Cu generated by _build_ground_planes().
   563	        if disc.return_vias is not None:
   564	            if self._f1_composition is not None and self._f1_composition.return_vias:
   565	                # Use pre-computed return via positions from the F1 builder
   566	                for i, return_via in enumerate(self._f1_composition.return_vias):
   567	                    via_uuid = self._indexed_uuid("via.return", i)
   568	                    vias.append(
   569	                        [
   570	                            "via",
   571	                            ["at", nm_to_mm(return_via.position.x), nm_to_mm(return_via.position.y)],
   572	                            ["size", nm_to_mm(return_via.diameter_nm)],
   573	                            ["drill", nm_to_mm(return_via.drill_nm)],
   574	                            ["layers", return_via.layers[0], return_via.layers[1]],
   575	                            ["net", 2],  # GND net
   576	                            ["tstamp", via_uuid],
   577	                        ]
   578	                    )
   579	            else:
   580	                # Fallback calculation using LayoutPlan discontinuity position
   581	                rv = disc.return_vias
   582	                radius = int(rv.radius_nm)
   583	                count = rv.count
   584	
   585	                for i in range(count):
   586	                    angle = 2 * math.pi * i / count
   587	                    vx = center_x + int(radius * math.cos(angle))
   588	                    vy = center_y + int(radius * math.sin(angle))
   589	                    via_uuid = self._indexed_uuid("via.return", i)
   590	
   591	                    vias.append(
   592	                        [
   593	                            "via",
   594	                            ["at", nm_to_mm(vx), nm_to_mm(vy)],
   595	                            ["size", nm_to_mm(int(rv.via.diameter_nm))],
   596	                            ["drill", nm_to_mm(int(rv.via.drill_nm))],
   597	                            ["layers", "F.Cu", "B.Cu"],
   598	                            ["net", 2],  # GND net
   599	                            ["tstamp", via_uuid],
   600	                        ]
   601	                    )
   602	
   603	        return vias
   604	
   605	    def _build_antipads(self) -> list[SExprList]:
   606	        """Build antipad polygons for F1 coupons.
   607	
   608	        Antipads are cutout regions on internal copper layers that provide
   609	        clearance around the signal via. They are generated as zones with
   610	        keepout restrictions for copper fill, but allowing vias to pass through.
   611	
   612	        Note: The keepout allows vias because the signal via must pass through
   613	        the antipad area. The antipad's purpose is to clear copper fill from
   614	        ground planes, not to block the via structure itself.
   615	        """
   616	        antipads: list[SExprList] = []
   617	
   618	        if self._f1_composition is None:
   619	            return antipads
   620	
   621	        all_antipads = self._f1_composition.all_antipads
   622	        for i, antipad in enumerate(all_antipads):
   623	            antipad_uuid = self._indexed_uuid("antipad", i)
   624	
   625	            # Build the polygon points
   626	            pts: SExprList = ["pts"]
   627	            for vertex in antipad.vertices:
   628	                pts.append(["xy", nm_to_mm(vertex.x), nm_to_mm(vertex.y)])
   629	
   630	            # Map spec layer name to KiCad layer name
   631	            kicad_layer = map_layer_to_kicad(antipad.layer)
   632	
   633	            # Create a zone cutout on the appropriate layer
   634	            # Note: vias are "allowed" because the signal via must pass through
   635	            zone: SExprList = [
   636	                "zone",
   637	                ["net", 0],
   638	                ["net_name", ""],
   639	                ["layer", kicad_layer],
   640	                ["tstamp", antipad_uuid],
   641	                ["hatch", "edge", 0.5],
   642	                ["priority", 0],
   643	                ["connect_pads", ["clearance", 0]],
   644	                ["min_thickness", 0.1],
   645	                ["filled_areas_thickness", "no"],
   646	                [
   647	                    "keepout",
   648	                    ["tracks", "allowed"],
   649	                    ["vias", "allowed"],
   650	                    ["pads", "allowed"],
   651	                    ["copperpour", "not_allowed"],
   652	                    ["footprints", "allowed"],
   653	                ],
   654	                ["fill", ["thermal_gap", 0.5], ["thermal_bridge_width", 0.5]],
   655	                ["polygon", pts],
   656	            ]
   657	            antipads.append(zone)
   658	
   659	        return antipads
   660	
   661	    def _build_cutouts(self) -> list[SExprList]:
   662	        """Build plane cutout polygons for F1 coupons.
   663	
   664	        Plane cutouts are typically slot-shaped or rectangular regions
   665	        that provide impedance tuning or thermal relief around the via
   666	        transition. Like antipads, they block copper fill but allow vias.
   667	        """
   668	        cutouts: list[SExprList] = []
   669	
   670	        if self._f1_composition is None:
   671	            return cutouts
   672	
   673	        all_cutouts = self._f1_composition.all_cutouts
   674	        for i, cutout in enumerate(all_cutouts):
   675	            cutout_uuid = self._indexed_uuid("cutout", i)
   676	
   677	            # Build the polygon points
   678	            pts: SExprList = ["pts"]
   679	            for vertex in cutout.vertices:
   680	                pts.append(["xy", nm_to_mm(vertex.x), nm_to_mm(vertex.y)])
   681	
   682	            # Map spec layer name to KiCad layer name
   683	            kicad_layer = map_layer_to_kicad(cutout.layer)
   684	
   685	            # Create a zone cutout on the appropriate layer
   686	            # Note: vias are "allowed" - cutouts clear copper fill, not block vias
   687	            zone: SExprList = [
   688	                "zone",
   689	                ["net", 0],
   690	                ["net_name", ""],
   691	                ["layer", kicad_layer],
   692	                ["tstamp", cutout_uuid],
   693	                ["hatch", "edge", 0.5],
   694	                ["priority", 0],
   695	                ["connect_pads", ["clearance", 0]],
   696	                ["min_thickness", 0.1],
   697	                ["filled_areas_thickness", "no"],
   698	                [
   699	                    "keepout",
   700	                    ["tracks", "allowed"],
   701	                    ["vias", "allowed"],
   702	                    ["pads", "allowed"],
   703	                    ["copperpour", "not_allowed"],
   704	                    ["footprints", "allowed"],
   705	                ],
   706	                ["fill", ["thermal_gap", 0.5], ["thermal_bridge_width", 0.5]],
   707	                ["polygon", pts],
   708	            ]
   709	            cutouts.append(zone)
   710	
   711	        return cutouts
   712	
   713	    def _build_ground_planes(self) -> list[SExprList]:
   714	        """Build ground ring traces for return via connectivity.
   715	
   716	        Creates copper track segments connecting return vias in a ring on
   717	        F.Cu and B.Cu, connected to GND net. This ring provides the copper
   718	        connectivity that return vias need on each layer, satisfying KiCad
   719	        DRC via connectivity requirements.
   720	
   721	        The ring is drawn with trace width equal to the return via diameter
   722	        to ensure solid overlap with the via pads.
   723	        """
   724	        elements: list[SExprList] = []
   725	        disc = self.spec.discontinuity
   726	
   727	        if disc is None or disc.return_vias is None:
   728	            return elements
   729	
   730	        lp = self._layout_plan
   731	        center_x = lp.x_disc_nm
   732	        center_y = lp.y_centerline_nm
   733	
   734	        if center_x is None:
   735	            return elements
   736	
   737	        # Get return via positions and diameter
   738	        if self._f1_composition is not None and self._f1_composition.return_vias:
   739	            return_via_positions = [
   740	                (v.position.x, v.position.y)
   741	                for v in self._f1_composition.return_vias
   742	            ]
   743	            via_diameter = self._f1_composition.return_vias[0].diameter_nm if self._f1_composition.return_vias else 500000
   744	        else:
   745	            # Fallback: calculate positions
   746	            rv = disc.return_vias
   747	            radius = int(rv.radius_nm)
   748	            count = rv.count
   749	            via_diameter = int(rv.via.diameter_nm)
   750	            return_via_positions = []
   751	            for i in range(count):
   752	                angle = 2 * math.pi * i / count
   753	                vx = center_x + int(radius * math.cos(angle))
   754	                vy = center_y + int(radius * math.sin(angle))
   755	                return_via_positions.append((vx, vy))
   756	
   757	        if len(return_via_positions) < 2:
   758	            return elements
   759	
   760	        # Create ground ring on both F.Cu and B.Cu
   761	        # Connect vias in sequence, then close the ring
   762	        for layer in ["F.Cu", "B.Cu"]:
   763	            for i in range(len(return_via_positions)):
   764	                start_x, start_y = return_via_positions[i]
   765	                end_x, end_y = return_via_positions[(i + 1) % len(return_via_positions)]
   766	
   767	                track_uuid = self._indexed_uuid(f"gnd_ring.{layer}", i)
   768	
   769	                track: SExprList = [
   770	                    "segment",
   771	                    ["start", nm_to_mm(start_x), nm_to_mm(start_y)],
   772	                    ["end", nm_to_mm(end_x), nm_to_mm(end_y)],
   773	                    ["width", nm_to_mm(via_diameter)],  # Wide trace for solid overlap
   774	                    ["layer", layer],
   775	                    ["net", 2],  # GND net
   776	                    ["tstamp", track_uuid],
   777	                ]
   778	                elements.append(track)
   779	
   780	        return elements
   781	
   782	    def write(self, out_path: Path) -> None:
   783	        """Write the board file to disk.
   784	
   785	        Args:
   786	            out_path: Path for the output .kicad_pcb file.
   787	        """
   788	        board = self.build_board()
   789	        content = sexpr.dump(board)
   790	        out_path.write_text(content, encoding="utf-8")
   791	
   792	
   793	def build_board_sexpr(spec: CouponSpec, resolved: ResolvedDesign) -> SExprList:
   794	    """Build board S-expression from spec and resolved design.
   795	
   796	    Args:
   797	        spec: Coupon specification.
   798	        resolved: Resolved design parameters.
   799	
   800	    Returns:
   801	        S-expression list representing the board.
   802	    """
   803	    writer = BoardWriter(spec, resolved)
   804	    return writer.build_board()
   805	
   806	
   807	def build_board_text(spec: CouponSpec, resolved: ResolvedDesign) -> str:
   808	    """Build board file content from spec and resolved design.
   809	
   810	    Args:
   811	        spec: Coupon specification.
   812	        resolved: Resolved design parameters.
   813	
   814	    Returns:
   815	        Formatted S-expression string for .kicad_pcb file.
   816	    """
   817	    board = build_board_sexpr(spec, resolved)
   818	    return sexpr.dump(board)
   819	
   820	
   821	def write_board(spec: CouponSpec, resolved: ResolvedDesign, out_dir: Path) -> Path:
   822	    """Write board file to output directory.
   823	
   824	    Args:
   825	        spec: Coupon specification.
   826	        resolved: Resolved design parameters.
   827	        out_dir: Output directory path.
   828	
   829	    Returns:
   830	        Path to the generated .kicad_pcb file.
   831	    """
   832	    out_dir.mkdir(parents=True, exist_ok=True)
   833	    board_path = out_dir / "coupon.kicad_pcb"
   834	    writer = BoardWriter(spec, resolved)
   835	    writer.write(board_path)
   836	    return board_path

================================================================================
FILE: src/formula_foundry/coupongen/geom/layout.py
================================================================================
     1	"""Layout Plan dataclasses - Single Source of Truth for Coupon Geometry.
     2	
     3	This module defines the authoritative internal representation (IR) for coupon
     4	layout geometry. All placements, trace segments, and port positions derive from
     5	LayoutPlan to ensure topological consistency and eliminate duplicated geometry
     6	math.
     7	
     8	The LayoutPlan enforces a key invariant for F1 coupons:
     9	    x_discontinuity_center_nm == x_left_connector_ref_nm + length_left_nm
    10	    x_discontinuity_center_nm == x_right_connector_ref_nm - length_right_nm
    11	
    12	This guarantees that trace segments connect without gaps and the SIG net
    13	forms a single connected component.
    14	
    15	All coordinates use integer nanometers (nm) for determinism and hashability.
    16	
    17	Satisfies CP-2.1 (ECO-M1-ALIGN-0001).
    18	"""
    19	
    20	from __future__ import annotations
    21	
    22	import math
    23	from dataclasses import dataclass
    24	from typing import TYPE_CHECKING
    25	
    26	from .primitives import OriginMode
    27	
    28	if TYPE_CHECKING:
    29	    from ..resolve import ResolvedDesign
    30	    from ..spec import CouponSpec
    31	
    32	
    33	@dataclass(frozen=True, slots=True)
    34	class PortPlan:
    35	    """Port placement plan for a connector.
    36	
    37	    Defines the reference position and signal pad anchor for a port
    38	    (end-launch connector) in the canonical coordinate frame.
    39	
    40	    Attributes:
    41	        x_ref_nm: X coordinate of the port reference point (connector center)
    42	                  in nanometers.
    43	        y_ref_nm: Y coordinate of the port reference point (usually 0 for
    44	                  centerline placement) in nanometers.
    45	        signal_pad_x_nm: X coordinate of the signal pad center in nanometers.
    46	                         This is where the transmission line connects.
    47	        signal_pad_y_nm: Y coordinate of the signal pad center in nanometers.
    48	        footprint: Full footprint path as 'library:name'.
    49	        rotation_mdeg: Rotation in millidegrees (0, 90000, 180000, 270000).
    50	        side: Port side identifier ('left' or 'right').
    51	    """
    52	
    53	    x_ref_nm: int
    54	    y_ref_nm: int
    55	    signal_pad_x_nm: int
    56	    signal_pad_y_nm: int
    57	    footprint: str
    58	    rotation_mdeg: int
    59	    side: str
    60	
    61	    def __post_init__(self) -> None:
    62	        """Validate port plan invariants."""
    63	        if self.side not in ("left", "right"):
    64	            raise ValueError(f"Port side must be 'left' or 'right', got {self.side!r}")
    65	        if self.rotation_mdeg not in (0, 90000, 180000, 270000):
    66	            raise ValueError(
    67	                f"Rotation must be 0, 90000, 180000, or 270000 mdeg, got {self.rotation_mdeg}"
    68	            )
    69	
    70	
    71	@dataclass(frozen=True, slots=True)
    72	class SegmentPlan:
    73	    """Trace segment plan for a transmission line section.
    74	
    75	    Defines a single horizontal trace segment in the canonical coordinate
    76	    frame. All F0/F1 coupons use horizontal centerline traces (y=0).
    77	
    78	    Attributes:
    79	        x_start_nm: X coordinate of segment start in nanometers.
    80	        x_end_nm: X coordinate of segment end in nanometers.
    81	        y_nm: Y coordinate of the centerline in nanometers (typically 0).
    82	        width_nm: Trace width in nanometers.
    83	        layer: Copper layer name (e.g., "F.Cu", "B.Cu").
    84	        net_name: Net name for electrical connectivity (e.g., "SIG").
    85	        label: Human-readable label for the segment (e.g., "left", "right").
    86	    """
    87	
    88	    x_start_nm: int
    89	    x_end_nm: int
    90	    y_nm: int
    91	    width_nm: int
    92	    layer: str
    93	    net_name: str
    94	    label: str
    95	
    96	    def __post_init__(self) -> None:
    97	        """Validate segment plan invariants."""
    98	        if self.width_nm <= 0:
    99	            raise ValueError(f"Trace width must be positive, got {self.width_nm}")
   100	        if self.x_end_nm < self.x_start_nm:
   101	            raise ValueError(
   102	                f"Segment end ({self.x_end_nm}) must be >= start ({self.x_start_nm})"
   103	            )
   104	
   105	    @property
   106	    def length_nm(self) -> int:
   107	        """Computed length of the segment in nanometers."""
   108	        return self.x_end_nm - self.x_start_nm
   109	
   110	
   111	@dataclass(frozen=True, slots=True)
   112	class LayoutPlan:
   113	    """Authoritative layout plan for coupon geometry.
   114	
   115	    This is the single source of truth for all geometry in a coupon.
   116	    All placements and segments reference this plan  no duplicated geometry
   117	    math elsewhere.
   118	
   119	    Coordinate System (EDGE_L_CENTER):
   120	    - x_board_left_edge_nm = 0 (origin convention)
   121	    - y_centerline_nm = 0
   122	    - +x to the right, +y upward
   123	
   124	    Key Invariant for F1 coupons:
   125	        x_disc_nm == left_port.signal_pad_x_nm + segment_left.length_nm
   126	        x_disc_nm == right_port.signal_pad_x_nm - segment_right.length_nm
   127	
   128	    This ensures trace endpoints coincide at the discontinuity center.
   129	
   130	    Attributes:
   131	        origin_mode: Coordinate frame origin mode.
   132	        board_length_nm: Board length (X dimension) in nanometers.
   133	        board_width_nm: Board width (Y dimension) in nanometers.
   134	        board_corner_radius_nm: Board corner radius in nanometers.
   135	        left_port: Left port placement plan.
   136	        right_port: Right port placement plan.
   137	        segments: Tuple of trace segment plans (ordered left-to-right).
   138	        x_disc_nm: X coordinate of the discontinuity center in nanometers.
   139	                   None for F0 coupons (no discontinuity).
   140	        y_centerline_nm: Y coordinate of the signal centerline (typically 0).
   141	        coupon_family: Coupon family identifier (e.g., "F0", "F1").
   142	    """
   143	
   144	    origin_mode: OriginMode
   145	    board_length_nm: int
   146	    board_width_nm: int
   147	    board_corner_radius_nm: int
   148	    left_port: PortPlan
   149	    right_port: PortPlan
   150	    segments: tuple[SegmentPlan, ...]
   151	    x_disc_nm: int | None
   152	    y_centerline_nm: int
   153	    coupon_family: str
   154	
   155	    def __post_init__(self) -> None:
   156	        """Validate layout plan invariants."""
   157	        # Board dimensions must be positive
   158	        if self.board_length_nm <= 0:
   159	            raise ValueError(f"Board length must be positive, got {self.board_length_nm}")
   160	        if self.board_width_nm <= 0:
   161	            raise ValueError(f"Board width must be positive, got {self.board_width_nm}")
   162	        if self.board_corner_radius_nm < 0:
   163	            raise ValueError(
   164	                f"Board corner radius must be non-negative, got {self.board_corner_radius_nm}"
   165	            )
   166	
   167	        # At least one segment is required
   168	        if len(self.segments) == 0:
   169	            raise ValueError("At least one trace segment is required")
   170	
   171	        # For F1, validate the continuity invariant
   172	        if self.x_disc_nm is not None and len(self.segments) >= 2:
   173	            # Find left and right segments by label
   174	            left_seg = next((s for s in self.segments if s.label == "left"), None)
   175	            right_seg = next((s for s in self.segments if s.label == "right"), None)
   176	
   177	            if left_seg is not None and right_seg is not None:
   178	                # Left segment must end at discontinuity
   179	                if left_seg.x_end_nm != self.x_disc_nm:
   180	                    raise ValueError(
   181	                        f"Left segment end ({left_seg.x_end_nm}) must equal "
   182	                        f"discontinuity X ({self.x_disc_nm})"
   183	                    )
   184	                # Right segment must start at discontinuity
   185	                if right_seg.x_start_nm != self.x_disc_nm:
   186	                    raise ValueError(
   187	                        f"Right segment start ({right_seg.x_start_nm}) must equal "
   188	                        f"discontinuity X ({self.x_disc_nm})"
   189	                    )
   190	
   191	    @property
   192	    def x_board_left_edge_nm(self) -> int:
   193	        """X coordinate of the left board edge (always 0 in EDGE_L_CENTER)."""
   194	        return 0
   195	
   196	    @property
   197	    def x_board_right_edge_nm(self) -> int:
   198	        """X coordinate of the right board edge."""
   199	        return self.board_length_nm
   200	
   201	    @property
   202	    def y_board_top_edge_nm(self) -> int:
   203	        """Y coordinate of the top board edge."""
   204	        return self.board_width_nm // 2
   205	
   206	    @property
   207	    def y_board_bottom_edge_nm(self) -> int:
   208	        """Y coordinate of the bottom board edge."""
   209	        return -(self.board_width_nm // 2)
   210	
   211	    @property
   212	    def total_trace_length_nm(self) -> int:
   213	        """Total length of all trace segments in nanometers."""
   214	        return sum(seg.length_nm for seg in self.segments)
   215	
   216	    @property
   217	    def has_discontinuity(self) -> bool:
   218	        """Whether this layout includes a discontinuity (via transition)."""
   219	        return self.x_disc_nm is not None
   220	
   221	    def get_segment_by_label(self, label: str) -> SegmentPlan | None:
   222	        """Get a segment by its label.
   223	
   224	        Args:
   225	            label: Segment label (e.g., "left", "right", "through").
   226	
   227	        Returns:
   228	            The matching SegmentPlan, or None if not found.
   229	        """
   230	        return next((s for s in self.segments if s.label == label), None)
   231	
   232	    def validate_connectivity(self) -> list[str]:
   233	        """Validate that all segments are connected.
   234	
   235	        Checks that consecutive segments share endpoints and that
   236	        the first/last segments connect to ports.
   237	
   238	        Returns:
   239	            List of validation error messages (empty if valid).
   240	        """
   241	        errors: list[str] = []
   242	
   243	        # Check segment connectivity
   244	        for i in range(len(self.segments) - 1):
   245	            curr = self.segments[i]
   246	            next_seg = self.segments[i + 1]
   247	            if curr.x_end_nm != next_seg.x_start_nm:
   248	                errors.append(
   249	                    f"Segment gap between '{curr.label}' end ({curr.x_end_nm}) "
   250	                    f"and '{next_seg.label}' start ({next_seg.x_start_nm})"
   251	                )
   252	
   253	        # Check first segment connects to left port signal pad
   254	        if self.segments:
   255	            first_seg = self.segments[0]
   256	            if first_seg.x_start_nm != self.left_port.signal_pad_x_nm:
   257	                errors.append(
   258	                    f"First segment start ({first_seg.x_start_nm}) doesn't match "
   259	                    f"left port signal pad X ({self.left_port.signal_pad_x_nm})"
   260	                )
   261	
   262	            last_seg = self.segments[-1]
   263	            if last_seg.x_end_nm != self.right_port.signal_pad_x_nm:
   264	                errors.append(
   265	                    f"Last segment end ({last_seg.x_end_nm}) doesn't match "
   266	                    f"right port signal pad X ({self.right_port.signal_pad_x_nm})"
   267	                )
   268	
   269	        return errors
   270	
   271	
   272	def create_f0_layout_plan(
   273	    *,
   274	    board_length_nm: int,
   275	    board_width_nm: int,
   276	    board_corner_radius_nm: int,
   277	    left_port_x_nm: int,
   278	    right_port_x_nm: int,
   279	    trace_width_nm: int,
   280	    trace_layer: str,
   281	    footprint: str,
   282	) -> LayoutPlan:
   283	    """Create a LayoutPlan for an F0 (through-line) coupon.
   284	
   285	    F0 coupons have a single continuous trace from left to right port
   286	    with no discontinuity.
   287	
   288	    Args:
   289	        board_length_nm: Board length in nanometers.
   290	        board_width_nm: Board width in nanometers.
   291	        board_corner_radius_nm: Board corner radius in nanometers.
   292	        left_port_x_nm: X position of left connector reference point.
   293	        right_port_x_nm: X position of right connector reference point.
   294	        trace_width_nm: Trace width in nanometers.
   295	        trace_layer: Copper layer name.
   296	        footprint: Connector footprint path.
   297	
   298	    Returns:
   299	        LayoutPlan for the F0 coupon.
   300	    """
   301	    left_port = PortPlan(
   302	        x_ref_nm=left_port_x_nm,
   303	        y_ref_nm=0,
   304	        signal_pad_x_nm=left_port_x_nm,  # Simplified: pad at ref point
   305	        signal_pad_y_nm=0,
   306	        footprint=footprint,
   307	        rotation_mdeg=0,
   308	        side="left",
   309	    )
   310	
   311	    right_port = PortPlan(
   312	        x_ref_nm=right_port_x_nm,
   313	        y_ref_nm=0,
   314	        signal_pad_x_nm=right_port_x_nm,  # Simplified: pad at ref point
   315	        signal_pad_y_nm=0,
   316	        footprint=footprint,
   317	        rotation_mdeg=180000,
   318	        side="right",
   319	    )
   320	
   321	    # Single through segment
   322	    through_segment = SegmentPlan(
   323	        x_start_nm=left_port_x_nm,
   324	        x_end_nm=right_port_x_nm,
   325	        y_nm=0,
   326	        width_nm=trace_width_nm,
   327	        layer=trace_layer,
   328	        net_name="SIG",
   329	        label="through",
   330	    )
   331	
   332	    return LayoutPlan(
   333	        origin_mode=OriginMode.EDGE_L_CENTER,
   334	        board_length_nm=board_length_nm,
   335	        board_width_nm=board_width_nm,
   336	        board_corner_radius_nm=board_corner_radius_nm,
   337	        left_port=left_port,
   338	        right_port=right_port,
   339	        segments=(through_segment,),
   340	        x_disc_nm=None,
   341	        y_centerline_nm=0,
   342	        coupon_family="F0_THROUGH_LINE",
   343	    )
   344	
   345	
   346	def create_f1_layout_plan(
   347	    *,
   348	    board_length_nm: int,
   349	    board_width_nm: int,
   350	    board_corner_radius_nm: int,
   351	    left_port_x_nm: int,
   352	    right_port_x_nm: int,
   353	    left_length_nm: int,
   354	    trace_width_nm: int,
   355	    trace_layer: str,
   356	    footprint: str,
   357	) -> LayoutPlan:
   358	    """Create a LayoutPlan for an F1 (via transition) coupon.
   359	
   360	    F1 coupons have two trace segments connecting at a via transition
   361	    (discontinuity). The right length is derived to ensure continuity:
   362	        right_length_nm = right_port_x_nm - (left_port_x_nm + left_length_nm)
   363	
   364	    This enforces the key invariant that both segments meet at the
   365	    discontinuity center.
   366	
   367	    Args:
   368	        board_length_nm: Board length in nanometers.
   369	        board_width_nm: Board width in nanometers.
   370	        board_corner_radius_nm: Board corner radius in nanometers.
   371	        left_port_x_nm: X position of left connector reference point.
   372	        right_port_x_nm: X position of right connector reference point.
   373	        left_length_nm: Length of the left trace segment.
   374	        trace_width_nm: Trace width in nanometers.
   375	        trace_layer: Copper layer name.
   376	        footprint: Connector footprint path.
   377	
   378	    Returns:
   379	        LayoutPlan for the F1 coupon.
   380	
   381	    Raises:
   382	        ValueError: If left_length_nm results in discontinuity outside board.
   383	    """
   384	    # Derive discontinuity position
   385	    x_disc_nm = left_port_x_nm + left_length_nm
   386	
   387	    # Derive right length to ensure continuity
   388	    right_length_nm = right_port_x_nm - x_disc_nm
   389	
   390	    if right_length_nm < 0:
   391	        raise ValueError(
   392	            f"Left length ({left_length_nm}) places discontinuity ({x_disc_nm}) "
   393	            f"beyond right port ({right_port_x_nm})"
   394	        )
   395	
   396	    left_port = PortPlan(
   397	        x_ref_nm=left_port_x_nm,
   398	        y_ref_nm=0,
   399	        signal_pad_x_nm=left_port_x_nm,
   400	        signal_pad_y_nm=0,
   401	        footprint=footprint,
   402	        rotation_mdeg=0,
   403	        side="left",
   404	    )
   405	
   406	    right_port = PortPlan(
   407	        x_ref_nm=right_port_x_nm,
   408	        y_ref_nm=0,
   409	        signal_pad_x_nm=right_port_x_nm,
   410	        signal_pad_y_nm=0,
   411	        footprint=footprint,
   412	        rotation_mdeg=180000,
   413	        side="right",
   414	    )
   415	
   416	    # Left segment: from left port to discontinuity
   417	    left_segment = SegmentPlan(
   418	        x_start_nm=left_port_x_nm,
   419	        x_end_nm=x_disc_nm,
   420	        y_nm=0,
   421	        width_nm=trace_width_nm,
   422	        layer=trace_layer,
   423	        net_name="SIG",
   424	        label="left",
   425	    )
   426	
   427	    # Right segment: from discontinuity to right port
   428	    right_segment = SegmentPlan(
   429	        x_start_nm=x_disc_nm,
   430	        x_end_nm=right_port_x_nm,
   431	        y_nm=0,
   432	        width_nm=trace_width_nm,
   433	        layer=trace_layer,
   434	        net_name="SIG",
   435	        label="right",
   436	    )
   437	
   438	    return LayoutPlan(
   439	        origin_mode=OriginMode.EDGE_L_CENTER,
   440	        board_length_nm=board_length_nm,
   441	        board_width_nm=board_width_nm,
   442	        board_corner_radius_nm=board_corner_radius_nm,
   443	        left_port=left_port,
   444	        right_port=right_port,
   445	        segments=(left_segment, right_segment),
   446	        x_disc_nm=x_disc_nm,
   447	        y_centerline_nm=0,
   448	        coupon_family="F1_SINGLE_ENDED_VIA",
   449	    )
   450	
   451	
   452	def derive_right_length_nm(
   453	    left_port_x_nm: int,
   454	    right_port_x_nm: int,
   455	    left_length_nm: int,
   456	) -> int:
   457	    """Derive the right trace length to ensure F1 continuity.
   458	
   459	    Given the port positions and left trace length, compute the right
   460	    trace length such that both segments meet at the discontinuity.
   461	
   462	    Args:
   463	        left_port_x_nm: X position of left connector.
   464	        right_port_x_nm: X position of right connector.
   465	        left_length_nm: Length of the left trace segment.
   466	
   467	    Returns:
   468	        The derived right trace length in nanometers.
   469	
   470	    Raises:
   471	        ValueError: If the derived length is negative.
   472	    """
   473	    x_disc_nm = left_port_x_nm + left_length_nm
   474	    right_length_nm = right_port_x_nm - x_disc_nm
   475	
   476	    if right_length_nm < 0:
   477	        raise ValueError(
   478	            f"Derived right length is negative ({right_length_nm}). "
   479	            f"Left length ({left_length_nm}) is too long for the given port positions."
   480	        )
   481	
   482	    return right_length_nm
   483	
   484	
   485	def compute_layout_plan(
   486	    spec: CouponSpec,
   487	    resolved: ResolvedDesign,  # noqa: ARG001 - reserved for future use
   488	) -> LayoutPlan:
   489	    """Compute LayoutPlan from CouponSpec and ResolvedDesign.
   490	
   491	    This is the main entry point for computing layout geometry from a
   492	    specification. It loads footprint metadata to get pad centers,
   493	    enforces EDGE_L_CENTER origin, and for F1 coupons derives the right
   494	    trace length from the continuity formula.
   495	
   496	    For F1 coupons, the continuity formula is:
   497	        xD = xL + length_left  (discontinuity position)
   498	        length_right = xR - xD (derived to ensure continuity)
   499	
   500	    where xL and xR are the signal pad X positions of the left and right
   501	    connectors.
   502	
   503	    Args:
   504	        spec: The coupon specification with all geometry parameters.
   505	        resolved: The resolved design (reserved for future extensions).
   506	
   507	    Returns:
   508	        LayoutPlan with all geometry computed and validated.
   509	
   510	    Raises:
   511	        FileNotFoundError: If footprint metadata cannot be loaded.
   512	        ValueError: If geometry constraints cannot be satisfied.
   513	
   514	    Satisfies CP-2.3 per ECO-M1-ALIGN-0001 Section 13.2.4.
   515	    """
   516	    from ..families import FAMILY_F0, FAMILY_F1
   517	    from .footprint_meta import load_footprint_meta
   518	
   519	    # Extract board dimensions
   520	    board_length_nm = int(spec.board.outline.length_nm)
   521	    board_width_nm = int(spec.board.outline.width_nm)
   522	    board_corner_radius_nm = int(spec.board.outline.corner_radius_nm)
   523	
   524	    # Load footprint metadata for left and right connectors
   525	    left_footprint = spec.connectors.left.footprint
   526	    right_footprint = spec.connectors.right.footprint
   527	
   528	    left_meta = load_footprint_meta(left_footprint)
   529	    right_meta = load_footprint_meta(right_footprint)
   530	
   531	    # Get connector placement positions from spec
   532	    left_connector_pos = spec.connectors.left.position_nm
   533	    right_connector_pos = spec.connectors.right.position_nm
   534	    left_rotation_deg = spec.connectors.left.rotation_deg
   535	    right_rotation_deg = spec.connectors.right.rotation_deg
   536	
   537	    # Compute signal pad positions in board coordinates
   538	    # The pad center is relative to the anchor, so we need to transform
   539	    # based on connector placement and rotation
   540	    left_signal_pad_x, left_signal_pad_y = _transform_pad_position(
   541	        anchor_x=int(left_connector_pos[0]),
   542	        anchor_y=int(left_connector_pos[1]),
   543	        pad_offset_x=left_meta.signal_pad.center_x_nm,
   544	        pad_offset_y=left_meta.signal_pad.center_y_nm,
   545	        rotation_deg=left_rotation_deg,
   546	    )
   547	
   548	    right_signal_pad_x, right_signal_pad_y = _transform_pad_position(
   549	        anchor_x=int(right_connector_pos[0]),
   550	        anchor_y=int(right_connector_pos[1]),
   551	        pad_offset_x=right_meta.signal_pad.center_x_nm,
   552	        pad_offset_y=right_meta.signal_pad.center_y_nm,
   553	        rotation_deg=right_rotation_deg,
   554	    )
   555	
   556	    # Get trace parameters
   557	    trace_width_nm = int(spec.transmission_line.w_nm)
   558	    trace_layer = spec.transmission_line.layer
   559	    length_left_nm = int(spec.transmission_line.length_left_nm)
   560	
   561	    # Build port plans
   562	    left_port = PortPlan(
   563	        x_ref_nm=int(left_connector_pos[0]),
   564	        y_ref_nm=int(left_connector_pos[1]),
   565	        signal_pad_x_nm=left_signal_pad_x,
   566	        signal_pad_y_nm=left_signal_pad_y,
   567	        footprint=left_meta.footprint_path,
   568	        rotation_mdeg=left_rotation_deg * 1000,
   569	        side="left",
   570	    )
   571	
   572	    right_port = PortPlan(
   573	        x_ref_nm=int(right_connector_pos[0]),
   574	        y_ref_nm=int(right_connector_pos[1]),
   575	        signal_pad_x_nm=right_signal_pad_x,
   576	        signal_pad_y_nm=right_signal_pad_y,
   577	        footprint=right_meta.footprint_path,
   578	        rotation_mdeg=right_rotation_deg * 1000,
   579	        side="right",
   580	    )
   581	
   582	    # Dispatch based on coupon family
   583	    if spec.coupon_family == FAMILY_F0:
   584	        return _compute_f0_layout(
   585	            board_length_nm=board_length_nm,
   586	            board_width_nm=board_width_nm,
   587	            board_corner_radius_nm=board_corner_radius_nm,
   588	            left_port=left_port,
   589	            right_port=right_port,
   590	            trace_width_nm=trace_width_nm,
   591	            trace_layer=trace_layer,
   592	        )
   593	    elif spec.coupon_family == FAMILY_F1:
   594	        return _compute_f1_layout(
   595	            board_length_nm=board_length_nm,
   596	            board_width_nm=board_width_nm,
   597	            board_corner_radius_nm=board_corner_radius_nm,
   598	            left_port=left_port,
   599	            right_port=right_port,
   600	            trace_width_nm=trace_width_nm,
   601	            trace_layer=trace_layer,
   602	            length_left_nm=length_left_nm,
   603	        )
   604	    else:
   605	        raise ValueError(f"Unsupported coupon family: {spec.coupon_family}")
   606	
   607	
   608	def _transform_pad_position(
   609	    anchor_x: int,
   610	    anchor_y: int,
   611	    pad_offset_x: int,
   612	    pad_offset_y: int,
   613	    rotation_deg: int,
   614	) -> tuple[int, int]:
   615	    """Transform pad position from footprint-relative to board coordinates.
   616	
   617	    Args:
   618	        anchor_x: Connector anchor X position in board coordinates.
   619	        anchor_y: Connector anchor Y position in board coordinates.
   620	        pad_offset_x: Pad X offset relative to footprint anchor.
   621	        pad_offset_y: Pad Y offset relative to footprint anchor.
   622	        rotation_deg: Connector rotation in degrees.
   623	
   624	    Returns:
   625	        Tuple of (x, y) pad position in board coordinates.
   626	    """
   627	    # Apply rotation to the pad offset
   628	    rad = math.radians(rotation_deg)
   629	    cos_r = math.cos(rad)
   630	    sin_r = math.sin(rad)
   631	
   632	    # Rotate offset vector
   633	    rotated_x = pad_offset_x * cos_r - pad_offset_y * sin_r
   634	    rotated_y = pad_offset_x * sin_r + pad_offset_y * cos_r
   635	
   636	    # Add to anchor position (round to int for determinism)
   637	    return (
   638	        anchor_x + round(rotated_x),
   639	        anchor_y + round(rotated_y),
   640	    )
   641	
   642	
   643	def _compute_f0_layout(
   644	    *,
   645	    board_length_nm: int,
   646	    board_width_nm: int,
   647	    board_corner_radius_nm: int,
   648	    left_port: PortPlan,
   649	    right_port: PortPlan,
   650	    trace_width_nm: int,
   651	    trace_layer: str,
   652	) -> LayoutPlan:
   653	    """Compute layout for F0 (through-line) coupon.
   654	
   655	    F0 coupons have a single continuous trace from left to right port.
   656	    """
   657	    # Single through segment from left signal pad to right signal pad
   658	    through_segment = SegmentPlan(
   659	        x_start_nm=left_port.signal_pad_x_nm,
   660	        x_end_nm=right_port.signal_pad_x_nm,
   661	        y_nm=left_port.signal_pad_y_nm,  # Assume centerline at y=0
   662	        width_nm=trace_width_nm,
   663	        layer=trace_layer,
   664	        net_name="SIG",
   665	        label="through",
   666	    )
   667	
   668	    return LayoutPlan(
   669	        origin_mode=OriginMode.EDGE_L_CENTER,
   670	        board_length_nm=board_length_nm,
   671	        board_width_nm=board_width_nm,
   672	        board_corner_radius_nm=board_corner_radius_nm,
   673	        left_port=left_port,
   674	        right_port=right_port,
   675	        segments=(through_segment,),
   676	        x_disc_nm=None,
   677	        y_centerline_nm=left_port.signal_pad_y_nm,
   678	        coupon_family="F0_CAL_THRU_LINE",
   679	    )
   680	
   681	
   682	def _compute_f1_layout(
   683	    *,
   684	    board_length_nm: int,
   685	    board_width_nm: int,
   686	    board_corner_radius_nm: int,
   687	    left_port: PortPlan,
   688	    right_port: PortPlan,
   689	    trace_width_nm: int,
   690	    trace_layer: str,
   691	    length_left_nm: int,
   692	) -> LayoutPlan:
   693	    """Compute layout for F1 (via transition) coupon.
   694	
   695	    F1 coupons have two trace segments meeting at a via discontinuity.
   696	    The right length is derived from the continuity formula:
   697	        xD = xL + length_left (discontinuity position)
   698	        length_right = xR - xD (derived to ensure segments meet)
   699	
   700	    where xL is the left signal pad X and xR is the right signal pad X.
   701	
   702	    For proper via transition, the left segment uses the entry layer (e.g., F.Cu)
   703	    and the right segment uses the exit layer (B.Cu). The signal via connects
   704	    both layers, ensuring DRC clean (no via_dangling warnings).
   705	    """
   706	    # Discontinuity position: xD = xL + length_left
   707	    x_disc_nm = left_port.signal_pad_x_nm + length_left_nm
   708	
   709	    # Derived right length: xR - xD (the continuity formula)
   710	    derived_right_length = right_port.signal_pad_x_nm - x_disc_nm
   711	
   712	    if derived_right_length < 0:
   713	        raise ValueError(
   714	            f"Left length ({length_left_nm}) places discontinuity ({x_disc_nm}) "
   715	            f"beyond right signal pad ({right_port.signal_pad_x_nm}). "
   716	            f"Derived right length would be negative ({derived_right_length})."
   717	        )
   718	
   719	    # Determine entry and exit layers for via transition
   720	    # Entry layer is from spec (typically F.Cu), exit layer is B.Cu for 4-layer boards
   721	    entry_layer = trace_layer
   722	    exit_layer = "B.Cu" if trace_layer == "F.Cu" else "F.Cu"
   723	
   724	    # Left segment: from left signal pad to discontinuity (entry layer)
   725	    left_segment = SegmentPlan(
   726	        x_start_nm=left_port.signal_pad_x_nm,
   727	        x_end_nm=x_disc_nm,
   728	        y_nm=left_port.signal_pad_y_nm,
   729	        width_nm=trace_width_nm,
   730	        layer=entry_layer,
   731	        net_name="SIG",
   732	        label="left",
   733	    )
   734	
   735	    # Right segment: from discontinuity to right signal pad (exit layer)
   736	    # This ensures the signal via connects traces on both layers
   737	    right_segment = SegmentPlan(
   738	        x_start_nm=x_disc_nm,
   739	        x_end_nm=right_port.signal_pad_x_nm,
   740	        y_nm=right_port.signal_pad_y_nm,
   741	        width_nm=trace_width_nm,
   742	        layer=exit_layer,
   743	        net_name="SIG",
   744	        label="right",
   745	    )
   746	
   747	    return LayoutPlan(
   748	        origin_mode=OriginMode.EDGE_L_CENTER,
   749	        board_length_nm=board_length_nm,
   750	        board_width_nm=board_width_nm,
   751	        board_corner_radius_nm=board_corner_radius_nm,
   752	        left_port=left_port,
   753	        right_port=right_port,
   754	        segments=(left_segment, right_segment),
   755	        x_disc_nm=x_disc_nm,
   756	        y_centerline_nm=left_port.signal_pad_y_nm,
   757	        coupon_family="F1_SINGLE_ENDED_VIA",
   758	    )

================================================================================
FILE: coupongen/layer_sets.json
================================================================================
     1	{
     2	  "$schema": "https://formula-foundry.dev/schemas/layer-sets.v1.json",
     3	  "schema_version": 1,
     4	  "description": "Expected layer sets per family and layer count (per Section 13.5.3)",
     5	  "layer_sets": {
     6	    "2_layer": {
     7	      "copper": ["F.Cu", "B.Cu"],
     8	      "mask": ["F.Mask", "B.Mask"],
     9	      "silkscreen": ["F.SilkS", "B.SilkS"],
    10	      "edge": ["Edge.Cuts"],
    11	      "required": ["F.Cu", "B.Cu", "F.Mask", "B.Mask", "Edge.Cuts"],
    12	      "optional": ["F.SilkS", "B.SilkS", "F.Paste", "B.Paste"]
    13	    },
    14	    "4_layer": {
    15	      "copper": ["F.Cu", "In1.Cu", "In2.Cu", "B.Cu"],
    16	      "mask": ["F.Mask", "B.Mask"],
    17	      "silkscreen": ["F.SilkS", "B.SilkS"],
    18	      "edge": ["Edge.Cuts"],
    19	      "required": ["F.Cu", "In1.Cu", "In2.Cu", "B.Cu", "F.Mask", "B.Mask", "Edge.Cuts"],
    20	      "optional": ["F.SilkS", "B.SilkS", "F.Paste", "B.Paste"]
    21	    },
    22	    "6_layer": {
    23	      "copper": ["F.Cu", "In1.Cu", "In2.Cu", "In3.Cu", "In4.Cu", "B.Cu"],
    24	      "mask": ["F.Mask", "B.Mask"],
    25	      "silkscreen": ["F.SilkS", "B.SilkS"],
    26	      "edge": ["Edge.Cuts"],
    27	      "required": ["F.Cu", "In1.Cu", "In2.Cu", "In3.Cu", "In4.Cu", "B.Cu", "F.Mask", "B.Mask", "Edge.Cuts"],
    28	      "optional": ["F.SilkS", "B.SilkS", "F.Paste", "B.Paste"]
    29	    }
    30	  },
    31	  "family_overrides": {
    32	    "F0_CAL_THRU_LINE": {
    33	      "description": "Calibration through-line coupon - single layer signal trace",
    34	      "signal_layers_min": 1,
    35	      "requires_via_layers": false
    36	    },
    37	    "F1_SINGLE_ENDED_VIA": {
    38	      "description": "Single-ended via transition coupon - requires at least 2 copper layers for via",
    39	      "signal_layers_min": 2,
    40	      "requires_via_layers": true
    41	    }
    42	  },
    43	  "gerber_extension_map": {
    44	    "F.Cu": "-F_Cu.gtl",
    45	    "B.Cu": "-B_Cu.gbl",
    46	    "In1.Cu": "-In1_Cu.g1",
    47	    "In2.Cu": "-In2_Cu.g2",
    48	    "In3.Cu": "-In3_Cu.g3",
    49	    "In4.Cu": "-In4_Cu.g4",
    50	    "F.Mask": "-F_Mask.gts",
    51	    "B.Mask": "-B_Mask.gbs",
    52	    "F.SilkS": "-F_Silkscreen.gto",
    53	    "B.SilkS": "-B_Silkscreen.gbo",
    54	    "F.Paste": "-F_Paste.gtp",
    55	    "B.Paste": "-B_Paste.gbp",
    56	    "Edge.Cuts": "-Edge_Cuts.gm1"
    57	  }
    58	}

================================================================================
FILE: src/formula_foundry/coupongen/layer_validation.py
================================================================================
     1	"""Layer set validation for coupon generation exports.
     2	
     3	This module defines expected layer sets per family and validates that all
     4	required layers are present in export outputs.
     5	
     6	Per Section 13.5.3 of the design doc:
     7	    Define and enforce a locked set for fabrication exports:
     8	    - F.Cu, In1.Cu, In2.Cu, B.Cu (for 4-layer boards)
     9	    - F.Mask, B.Mask
    10	    - F.SilkS, B.SilkS (optional for fab but commonly included)
    11	    - Edge.Cuts
    12	
    13	    Enforce in tests that every exported fab directory contains all expected layers.
    14	"""
    15	
    16	from __future__ import annotations
    17	
    18	import json
    19	from dataclasses import dataclass
    20	from functools import lru_cache
    21	from pathlib import Path
    22	
    23	# Path to layer sets configuration
    24	LAYER_SETS_PATH = Path(__file__).resolve().parents[3] / "coupongen" / "layer_sets.json"
    25	
    26	
    27	@dataclass(frozen=True)
    28	class LayerSetConfig:
    29	    """Configuration for a layer set based on copper layer count."""
    30	
    31	    copper: tuple[str, ...]
    32	    mask: tuple[str, ...]
    33	    silkscreen: tuple[str, ...]
    34	    edge: tuple[str, ...]
    35	    required: tuple[str, ...]
    36	    optional: tuple[str, ...]
    37	
    38	    @property
    39	    def all_layers(self) -> tuple[str, ...]:
    40	        """Return all layers (required + optional)."""
    41	        return self.required + self.optional
    42	
    43	
    44	@dataclass(frozen=True)
    45	class FamilyOverride:
    46	    """Family-specific layer requirements."""
    47	
    48	    description: str
    49	    signal_layers_min: int
    50	    requires_via_layers: bool
    51	
    52	
    53	@dataclass(frozen=True)
    54	class LayerValidationResult:
    55	    """Result of layer set validation."""
    56	
    57	    passed: bool
    58	    missing_layers: tuple[str, ...]
    59	    extra_layers: tuple[str, ...]
    60	    expected_layers: tuple[str, ...]
    61	    actual_layers: tuple[str, ...]
    62	    copper_layer_count: int
    63	    family: str
    64	
    65	
    66	class LayerSetValidationError(Exception):
    67	    """Raised when layer set validation fails."""
    68	
    69	    def __init__(self, result: LayerValidationResult):
    70	        self.result = result
    71	        missing = ", ".join(result.missing_layers) if result.missing_layers else "none"
    72	        super().__init__(
    73	            f"Layer set validation failed for {result.family} "
    74	            f"({result.copper_layer_count}-layer): missing layers: {missing}"
    75	        )
    76	
    77	
    78	@lru_cache(maxsize=1)
    79	def _load_layer_sets_config() -> dict:
    80	    """Load and cache the layer sets configuration."""
    81	    if not LAYER_SETS_PATH.exists():
    82	        raise FileNotFoundError(f"Layer sets configuration not found: {LAYER_SETS_PATH}")
    83	    with open(LAYER_SETS_PATH, encoding="utf-8") as f:
    84	        return json.load(f)
    85	
    86	
    87	def get_layer_set_for_copper_count(copper_layers: int) -> LayerSetConfig:
    88	    """Get the layer set configuration for a given copper layer count.
    89	
    90	    Args:
    91	        copper_layers: Number of copper layers (2, 4, 6, etc.)
    92	
    93	    Returns:
    94	        LayerSetConfig for the specified copper count
    95	
    96	    Raises:
    97	        ValueError: If copper layer count is not supported
    98	    """
    99	    config = _load_layer_sets_config()
   100	    key = f"{copper_layers}_layer"
   101	
   102	    if key not in config["layer_sets"]:
   103	        supported = sorted(
   104	            int(k.replace("_layer", ""))
   105	            for k in config["layer_sets"]
   106	        )
   107	        raise ValueError(
   108	            f"Unsupported copper layer count: {copper_layers}. "
   109	            f"Supported counts: {supported}"
   110	        )
   111	
   112	    layer_set = config["layer_sets"][key]
   113	    return LayerSetConfig(
   114	        copper=tuple(layer_set["copper"]),
   115	        mask=tuple(layer_set["mask"]),
   116	        silkscreen=tuple(layer_set["silkscreen"]),
   117	        edge=tuple(layer_set["edge"]),
   118	        required=tuple(layer_set["required"]),
   119	        optional=tuple(layer_set["optional"]),
   120	    )
   121	
   122	
   123	def get_family_override(family: str) -> FamilyOverride | None:
   124	    """Get family-specific layer requirements.
   125	
   126	    Args:
   127	        family: Coupon family identifier (e.g., "F0_CAL_THRU_LINE")
   128	
   129	    Returns:
   130	        FamilyOverride if family has specific requirements, None otherwise
   131	    """
   132	    config = _load_layer_sets_config()
   133	    overrides = config.get("family_overrides", {})
   134	
   135	    if family not in overrides:
   136	        return None
   137	
   138	    override = overrides[family]
   139	    return FamilyOverride(
   140	        description=override["description"],
   141	        signal_layers_min=override["signal_layers_min"],
   142	        requires_via_layers=override["requires_via_layers"],
   143	    )
   144	
   145	
   146	def get_gerber_extension_map() -> dict[str, str]:
   147	    """Get mapping of layer names to gerber file extensions.
   148	
   149	    Returns:
   150	        Dictionary mapping layer names (e.g., "F.Cu") to extensions (e.g., "-F_Cu.gbr")
   151	    """
   152	    config = _load_layer_sets_config()
   153	    return dict(config.get("gerber_extension_map", {}))
   154	
   155	
   156	def extract_layers_from_exports(
   157	    export_paths: list[str],
   158	    gerber_dir: str = "gerbers/",
   159	) -> list[str]:
   160	    """Extract layer names from export file paths.
   161	
   162	    Args:
   163	        export_paths: List of relative paths to exported files
   164	        gerber_dir: Prefix for gerber directory (default "gerbers/")
   165	
   166	    Returns:
   167	        List of layer names found in exports
   168	    """
   169	    extension_map = get_gerber_extension_map()
   170	    # Invert map: extension -> layer name
   171	    ext_to_layer = {ext: layer for layer, ext in extension_map.items()}
   172	
   173	    layers = []
   174	    for path in export_paths:
   175	        # Only look at files in the gerber directory
   176	        if not path.startswith(gerber_dir):
   177	            continue
   178	
   179	        # Check each extension mapping
   180	        for ext, layer in ext_to_layer.items():
   181	            if path.endswith(ext):
   182	                layers.append(layer)
   183	                break
   184	
   185	    return layers
   186	
   187	
   188	def validate_layer_set(
   189	    export_paths: list[str],
   190	    copper_layers: int,
   191	    family: str,
   192	    *,
   193	    gerber_dir: str = "gerbers/",
   194	    strict: bool = True,
   195	) -> LayerValidationResult:
   196	    """Validate that all required layers are present in exports.
   197	
   198	    Args:
   199	        export_paths: List of relative paths to exported files
   200	        copper_layers: Number of copper layers in the design
   201	        family: Coupon family identifier
   202	        gerber_dir: Prefix for gerber directory (default "gerbers/")
   203	        strict: If True, all required layers must be present; if False, log warnings only
   204	
   205	    Returns:
   206	        LayerValidationResult with validation details
   207	
   208	    Raises:
   209	        LayerSetValidationError: If validation fails and strict=True
   210	    """
   211	    layer_set = get_layer_set_for_copper_count(copper_layers)
   212	    actual_layers = extract_layers_from_exports(export_paths, gerber_dir)
   213	
   214	    # Check for missing required layers
   215	    missing = [layer for layer in layer_set.required if layer not in actual_layers]
   216	
   217	    # Check for unexpected layers (not in required or optional)
   218	    all_expected = set(layer_set.required) | set(layer_set.optional)
   219	    extra = [layer for layer in actual_layers if layer not in all_expected]
   220	
   221	    passed = len(missing) == 0
   222	
   223	    result = LayerValidationResult(
   224	        passed=passed,
   225	        missing_layers=tuple(missing),
   226	        extra_layers=tuple(extra),
   227	        expected_layers=layer_set.required,
   228	        actual_layers=tuple(sorted(set(actual_layers))),
   229	        copper_layer_count=copper_layers,
   230	        family=family,
   231	    )
   232	
   233	    if not passed and strict:
   234	        raise LayerSetValidationError(result)
   235	
   236	    return result
   237	
   238	
   239	def validate_family_layer_requirements(
   240	    copper_layers: int,
   241	    family: str,
   242	) -> None:
   243	    """Validate that the copper layer count is sufficient for the family.
   244	
   245	    Args:
   246	        copper_layers: Number of copper layers in the design
   247	        family: Coupon family identifier
   248	
   249	    Raises:
   250	        ValueError: If the family requires more layers than available
   251	    """
   252	    override = get_family_override(family)
   253	    if override is None:
   254	        return
   255	
   256	    if copper_layers < override.signal_layers_min:
   257	        raise ValueError(
   258	            f"Family {family} requires at least {override.signal_layers_min} "
   259	            f"copper layers, but design has only {copper_layers}. "
   260	            f"({override.description})"
   261	        )
   262	
   263	
   264	def layer_validation_payload(result: LayerValidationResult) -> dict:
   265	    """Convert LayerValidationResult to a dictionary for manifest inclusion.
   266	
   267	    Args:
   268	        result: The validation result
   269	
   270	    Returns:
   271	        Dictionary suitable for JSON serialization
   272	    """
   273	    return {
   274	        "passed": result.passed,
   275	        "copper_layer_count": result.copper_layer_count,
   276	        "family": result.family,
   277	        "expected_layers": list(result.expected_layers),
   278	        "actual_layers": list(result.actual_layers),
   279	        "missing_layers": list(result.missing_layers),
   280	        "extra_layers": list(result.extra_layers),
   281	    }
   282	
   283	
   284	def clear_layer_sets_cache() -> None:
   285	    """Clear the layer sets configuration cache. Useful for testing."""
   286	    _load_layer_sets_config.cache_clear()

================================================================================
FILE: tests/test_layer_validation.py
================================================================================
     1	"""Tests for layer set validation per family.
     2	
     3	Verifies Section 13.5.3 requirements:
     4	    Define and enforce a locked set for fabrication exports:
     5	    - F.Cu, In1.Cu, In2.Cu, B.Cu (for 4-layer boards)
     6	    - F.Mask, B.Mask
     7	    - F.SilkS, B.SilkS (optional)
     8	    - Edge.Cuts
     9	
    10	    Enforce in tests that every exported fab directory contains all expected layers.
    11	"""
    12	
    13	from __future__ import annotations
    14	
    15	import pytest
    16	
    17	from formula_foundry.coupongen.layer_validation import (
    18	    FamilyOverride,
    19	    LayerSetConfig,
    20	    LayerSetValidationError,
    21	    LayerValidationResult,
    22	    clear_layer_sets_cache,
    23	    extract_layers_from_exports,
    24	    get_family_override,
    25	    get_gerber_extension_map,
    26	    get_layer_set_for_copper_count,
    27	    layer_validation_payload,
    28	    validate_family_layer_requirements,
    29	    validate_layer_set,
    30	)
    31	
    32	
    33	@pytest.fixture(autouse=True)
    34	def clear_cache():
    35	    """Clear layer sets cache before each test."""
    36	    clear_layer_sets_cache()
    37	    yield
    38	    clear_layer_sets_cache()
    39	
    40	
    41	class TestGetLayerSetForCopperCount:
    42	    """Tests for get_layer_set_for_copper_count function."""
    43	
    44	    def test_2_layer_returns_correct_layers(self) -> None:
    45	        layer_set = get_layer_set_for_copper_count(2)
    46	        assert isinstance(layer_set, LayerSetConfig)
    47	        assert layer_set.copper == ("F.Cu", "B.Cu")
    48	        assert "F.Cu" in layer_set.required
    49	        assert "B.Cu" in layer_set.required
    50	        assert "Edge.Cuts" in layer_set.required
    51	
    52	    def test_4_layer_returns_correct_layers(self) -> None:
    53	        layer_set = get_layer_set_for_copper_count(4)
    54	        assert isinstance(layer_set, LayerSetConfig)
    55	        assert layer_set.copper == ("F.Cu", "In1.Cu", "In2.Cu", "B.Cu")
    56	        assert "In1.Cu" in layer_set.required
    57	        assert "In2.Cu" in layer_set.required
    58	        assert "F.Mask" in layer_set.required
    59	        assert "B.Mask" in layer_set.required
    60	
    61	    def test_6_layer_returns_correct_layers(self) -> None:
    62	        layer_set = get_layer_set_for_copper_count(6)
    63	        assert isinstance(layer_set, LayerSetConfig)
    64	        assert len(layer_set.copper) == 6
    65	        assert "In3.Cu" in layer_set.copper
    66	        assert "In4.Cu" in layer_set.copper
    67	
    68	    def test_unsupported_layer_count_raises(self) -> None:
    69	        with pytest.raises(ValueError, match="Unsupported copper layer count"):
    70	            get_layer_set_for_copper_count(8)
    71	
    72	    def test_layer_set_has_mask_layers(self) -> None:
    73	        layer_set = get_layer_set_for_copper_count(4)
    74	        assert "F.Mask" in layer_set.mask
    75	        assert "B.Mask" in layer_set.mask
    76	
    77	    def test_layer_set_has_edge_cuts(self) -> None:
    78	        layer_set = get_layer_set_for_copper_count(4)
    79	        assert "Edge.Cuts" in layer_set.edge
    80	
    81	    def test_layer_set_optional_includes_silkscreen(self) -> None:
    82	        layer_set = get_layer_set_for_copper_count(4)
    83	        assert "F.SilkS" in layer_set.optional
    84	        assert "B.SilkS" in layer_set.optional
    85	
    86	    def test_all_layers_property(self) -> None:
    87	        layer_set = get_layer_set_for_copper_count(4)
    88	        all_layers = layer_set.all_layers
    89	        assert all(layer in all_layers for layer in layer_set.required)
    90	        assert all(layer in all_layers for layer in layer_set.optional)
    91	
    92	
    93	class TestGetFamilyOverride:
    94	    """Tests for get_family_override function."""
    95	
    96	    def test_f0_family_override(self) -> None:
    97	        override = get_family_override("F0_CAL_THRU_LINE")
    98	        assert override is not None
    99	        assert isinstance(override, FamilyOverride)
   100	        assert override.signal_layers_min == 1
   101	        assert override.requires_via_layers is False
   102	
   103	    def test_f1_family_override(self) -> None:
   104	        override = get_family_override("F1_SINGLE_ENDED_VIA")
   105	        assert override is not None
   106	        assert isinstance(override, FamilyOverride)
   107	        assert override.signal_layers_min == 2
   108	        assert override.requires_via_layers is True
   109	
   110	    def test_unknown_family_returns_none(self) -> None:
   111	        override = get_family_override("F99_UNKNOWN_FAMILY")
   112	        assert override is None
   113	
   114	
   115	class TestGetGerberExtensionMap:
   116	    """Tests for get_gerber_extension_map function."""
   117	
   118	    def test_returns_dict(self) -> None:
   119	        ext_map = get_gerber_extension_map()
   120	        assert isinstance(ext_map, dict)
   121	
   122	    def test_has_copper_layers(self) -> None:
   123	        ext_map = get_gerber_extension_map()
   124	        assert "F.Cu" in ext_map
   125	        assert "B.Cu" in ext_map
   126	
   127	    def test_extension_format(self) -> None:
   128	        ext_map = get_gerber_extension_map()
   129	        # KiCad uses industry-standard extensions like .gtl for F.Cu
   130	        assert ext_map["F.Cu"].endswith(".gtl")
   131	
   132	
   133	class TestExtractLayersFromExports:
   134	    """Tests for extract_layers_from_exports function."""
   135	
   136	    def test_extracts_copper_layers(self) -> None:
   137	        export_paths = [
   138	            "gerbers/board-F_Cu.gtl",
   139	            "gerbers/board-B_Cu.gbl",
   140	            "drill/drill.drl",
   141	        ]
   142	        layers = extract_layers_from_exports(export_paths)
   143	        assert "F.Cu" in layers
   144	        assert "B.Cu" in layers
   145	
   146	    def test_extracts_mask_layers(self) -> None:
   147	        export_paths = [
   148	            "gerbers/board-F_Mask.gts",
   149	            "gerbers/board-B_Mask.gbs",
   150	        ]
   151	        layers = extract_layers_from_exports(export_paths)
   152	        assert "F.Mask" in layers
   153	        assert "B.Mask" in layers
   154	
   155	    def test_extracts_inner_layers(self) -> None:
   156	        export_paths = [
   157	            "gerbers/board-In1_Cu.g1",
   158	            "gerbers/board-In2_Cu.g2",
   159	        ]
   160	        layers = extract_layers_from_exports(export_paths)
   161	        assert "In1.Cu" in layers
   162	        assert "In2.Cu" in layers
   163	
   164	    def test_ignores_non_gerber_files(self) -> None:
   165	        export_paths = [
   166	            "drill/drill.drl",
   167	            "board.kicad_pcb",
   168	        ]
   169	        layers = extract_layers_from_exports(export_paths)
   170	        assert len(layers) == 0
   171	
   172	    def test_ignores_files_outside_gerber_dir(self) -> None:
   173	        export_paths = [
   174	            "other/board-F_Cu.gtl",
   175	        ]
   176	        layers = extract_layers_from_exports(export_paths)
   177	        assert len(layers) == 0
   178	
   179	    def test_custom_gerber_dir(self) -> None:
   180	        export_paths = [
   181	            "fab/board-F_Cu.gtl",
   182	        ]
   183	        layers = extract_layers_from_exports(export_paths, gerber_dir="fab/")
   184	        assert "F.Cu" in layers
   185	
   186	
   187	class TestValidateFamilyLayerRequirements:
   188	    """Tests for validate_family_layer_requirements function."""
   189	
   190	    def test_f0_accepts_single_layer(self) -> None:
   191	        # Should not raise for 2+ layers
   192	        validate_family_layer_requirements(2, "F0_CAL_THRU_LINE")
   193	
   194	    def test_f1_requires_at_least_2_layers(self) -> None:
   195	        # F1 requires via transition, needs at least 2 layers
   196	        with pytest.raises(ValueError, match="requires at least 2"):
   197	            validate_family_layer_requirements(1, "F1_SINGLE_ENDED_VIA")
   198	
   199	    def test_f1_accepts_4_layers(self) -> None:
   200	        # Should not raise
   201	        validate_family_layer_requirements(4, "F1_SINGLE_ENDED_VIA")
   202	
   203	    def test_unknown_family_does_not_raise(self) -> None:
   204	        # Unknown families have no specific requirements
   205	        validate_family_layer_requirements(2, "F99_UNKNOWN")
   206	
   207	
   208	class TestValidateLayerSet:
   209	    """Tests for validate_layer_set function."""
   210	
   211	    def test_valid_4_layer_set_passes(self) -> None:
   212	        export_paths = [
   213	            "gerbers/board-F_Cu.gtl",
   214	            "gerbers/board-In1_Cu.g1",
   215	            "gerbers/board-In2_Cu.g2",
   216	            "gerbers/board-B_Cu.gbl",
   217	            "gerbers/board-F_Mask.gts",
   218	            "gerbers/board-B_Mask.gbs",
   219	            "gerbers/board-Edge_Cuts.gm1",
   220	        ]
   221	        result = validate_layer_set(
   222	            export_paths=export_paths,
   223	            copper_layers=4,
   224	            family="F1_SINGLE_ENDED_VIA",
   225	            strict=False,
   226	        )
   227	        assert result.passed is True
   228	        assert len(result.missing_layers) == 0
   229	
   230	    def test_missing_layer_fails(self) -> None:
   231	        export_paths = [
   232	            "gerbers/board-F_Cu.gtl",
   233	            # Missing In1.Cu, In2.Cu, B.Cu
   234	            "gerbers/board-F_Mask.gts",
   235	            "gerbers/board-B_Mask.gbs",
   236	            "gerbers/board-Edge_Cuts.gm1",
   237	        ]
   238	        result = validate_layer_set(
   239	            export_paths=export_paths,
   240	            copper_layers=4,
   241	            family="F1_SINGLE_ENDED_VIA",
   242	            strict=False,
   243	        )
   244	        assert result.passed is False
   245	        assert "In1.Cu" in result.missing_layers
   246	        assert "In2.Cu" in result.missing_layers
   247	        assert "B.Cu" in result.missing_layers
   248	
   249	    def test_strict_mode_raises_on_missing_layers(self) -> None:
   250	        export_paths = [
   251	            "gerbers/board-F_Cu.gtl",
   252	        ]
   253	        with pytest.raises(LayerSetValidationError) as exc_info:
   254	            validate_layer_set(
   255	                export_paths=export_paths,
   256	                copper_layers=4,
   257	                family="F1_SINGLE_ENDED_VIA",
   258	                strict=True,
   259	            )
   260	        assert exc_info.value.result.passed is False
   261	        assert len(exc_info.value.result.missing_layers) > 0
   262	
   263	    def test_2_layer_set_validation(self) -> None:
   264	        export_paths = [
   265	            "gerbers/board-F_Cu.gtl",
   266	            "gerbers/board-B_Cu.gbl",
   267	            "gerbers/board-F_Mask.gts",
   268	            "gerbers/board-B_Mask.gbs",
   269	            "gerbers/board-Edge_Cuts.gm1",
   270	        ]
   271	        result = validate_layer_set(
   272	            export_paths=export_paths,
   273	            copper_layers=2,
   274	            family="F0_CAL_THRU_LINE",
   275	            strict=False,
   276	        )
   277	        assert result.passed is True
   278	        assert result.copper_layer_count == 2
   279	
   280	    def test_extra_layers_recorded(self) -> None:
   281	        export_paths = [
   282	            "gerbers/board-F_Cu.gtl",
   283	            "gerbers/board-B_Cu.gbl",
   284	            "gerbers/board-F_Mask.gts",
   285	            "gerbers/board-B_Mask.gbs",
   286	            "gerbers/board-Edge_Cuts.gm1",
   287	            "gerbers/board-F_SilkS.gto",  # Optional
   288	        ]
   289	        result = validate_layer_set(
   290	            export_paths=export_paths,
   291	            copper_layers=2,
   292	            family="F0_CAL_THRU_LINE",
   293	            strict=False,
   294	        )
   295	        assert result.passed is True
   296	        # F.SilkS is optional, not extra
   297	        assert "F.SilkS" not in result.extra_layers
   298	
   299	
   300	class TestLayerValidationResult:
   301	    """Tests for LayerValidationResult dataclass."""
   302	
   303	    def test_result_immutable(self) -> None:
   304	        result = LayerValidationResult(
   305	            passed=True,
   306	            missing_layers=(),
   307	            extra_layers=(),
   308	            expected_layers=("F.Cu", "B.Cu"),
   309	            actual_layers=("F.Cu", "B.Cu"),
   310	            copper_layer_count=2,
   311	            family="F0_CAL_THRU_LINE",
   312	        )
   313	        with pytest.raises(AttributeError):
   314	            result.passed = False  # type: ignore
   315	
   316	
   317	class TestLayerValidationPayload:
   318	    """Tests for layer_validation_payload function."""
   319	
   320	    def test_payload_contains_required_fields(self) -> None:
   321	        result = LayerValidationResult(
   322	            passed=True,
   323	            missing_layers=(),
   324	            extra_layers=(),
   325	            expected_layers=("F.Cu", "B.Cu"),
   326	            actual_layers=("F.Cu", "B.Cu"),
   327	            copper_layer_count=2,
   328	            family="F0_CAL_THRU_LINE",
   329	        )
   330	        payload = layer_validation_payload(result)
   331	        assert "passed" in payload
   332	        assert "copper_layer_count" in payload
   333	        assert "family" in payload
   334	        assert "expected_layers" in payload
   335	        assert "actual_layers" in payload
   336	        assert "missing_layers" in payload
   337	        assert "extra_layers" in payload
   338	
   339	    def test_payload_converts_tuples_to_lists(self) -> None:
   340	        result = LayerValidationResult(
   341	            passed=True,
   342	            missing_layers=("In1.Cu",),
   343	            extra_layers=(),
   344	            expected_layers=("F.Cu", "B.Cu"),
   345	            actual_layers=("F.Cu",),
   346	            copper_layer_count=4,
   347	            family="F1_SINGLE_ENDED_VIA",
   348	        )
   349	        payload = layer_validation_payload(result)
   350	        assert isinstance(payload["expected_layers"], list)
   351	        assert isinstance(payload["actual_layers"], list)
   352	        assert isinstance(payload["missing_layers"], list)
   353	
   354	
   355	class TestLayerSetValidationError:
   356	    """Tests for LayerSetValidationError exception."""
   357	
   358	    def test_error_message_contains_family(self) -> None:
   359	        result = LayerValidationResult(
   360	            passed=False,
   361	            missing_layers=("In1.Cu", "In2.Cu"),
   362	            extra_layers=(),
   363	            expected_layers=("F.Cu", "In1.Cu", "In2.Cu", "B.Cu"),
   364	            actual_layers=("F.Cu", "B.Cu"),
   365	            copper_layer_count=4,
   366	            family="F1_SINGLE_ENDED_VIA",
   367	        )
   368	        error = LayerSetValidationError(result)
   369	        assert "F1_SINGLE_ENDED_VIA" in str(error)
   370	        assert "4-layer" in str(error)
   371	        assert "In1.Cu" in str(error)
   372	
   373	    def test_error_has_result_attribute(self) -> None:
   374	        result = LayerValidationResult(
   375	            passed=False,
   376	            missing_layers=("In1.Cu",),
   377	            extra_layers=(),
   378	            expected_layers=("F.Cu", "In1.Cu"),
   379	            actual_layers=("F.Cu",),
   380	            copper_layer_count=4,
   381	            family="F1_SINGLE_ENDED_VIA",
   382	        )
   383	        error = LayerSetValidationError(result)
   384	        assert error.result is result
   385	        assert error.result.passed is False

================================================================================
FILE: tests/gates/test_g4_export_completeness.py
================================================================================
     1	# SPDX-License-Identifier: MIT
     2	"""Gate G4 tests: Export completeness and layer set validation.
     3	
     4	This module tests:
     5	- Export layer set completeness per copper count
     6	- Required Gerber layers are present (F.Cu, B.Cu, masks, edge cuts)
     7	- Inner layer files present for 4+ layer boards
     8	- Drill files (PTH, NPTH) present
     9	- Manifest references all exported artifacts
    10	
    11	Per ECO-M1-ALIGN-0001:
    12	- REQ-M1-017: Gerber and drill file export via KiCad CLI
    13	- REQ-M1-025: CI must prove export completeness for all golden specs
    14	
    15	Section 13.5.3 specifies locked layer sets:
    16	- F.Cu, In1.Cu, In2.Cu, B.Cu (for 4-layer boards)
    17	- F.Mask, B.Mask
    18	- F.SilkS, B.SilkS (optional)
    19	- Edge.Cuts
    20	
    21	Pytest marker: gate_g4
    22	
    23	Note: Real KiCad export integration tests are in tests/integration/test_export_determinism_integration.py
    24	and require Docker. These tests verify the export logic without Docker.
    25	"""
    26	from __future__ import annotations
    27	
    28	import hashlib
    29	import json
    30	import subprocess
    31	from pathlib import Path
    32	from typing import Any
    33	
    34	import pytest
    35	
    36	from formula_foundry.coupongen import load_spec
    37	from formula_foundry.coupongen.layer_validation import (
    38	    FamilyOverride,
    39	    LayerSetConfig,
    40	    LayerSetValidationError,
    41	    LayerValidationResult,
    42	    extract_layers_from_exports,
    43	    get_family_override,
    44	    get_gerber_extension_map,
    45	    get_layer_set_for_copper_count,
    46	    validate_family_layer_requirements,
    47	    validate_layer_set,
    48	)
    49	
    50	# ---------------------------------------------------------------------------
    51	# Constants and paths
    52	# ---------------------------------------------------------------------------
    53	
    54	ROOT = Path(__file__).resolve().parents[2]
    55	TESTS_DIR = Path(__file__).resolve().parents[1]
    56	GOLDEN_SPECS_DIR = TESTS_DIR / "golden_specs"
    57	
    58	
    59	# ---------------------------------------------------------------------------
    60	# Helpers
    61	# ---------------------------------------------------------------------------
    62	
    63	
    64	def _collect_golden_specs() -> list[Path]:
    65	    """Collect all golden spec files (YAML only to avoid duplicates)."""
    66	    specs: list[Path] = []
    67	    specs.extend(sorted(GOLDEN_SPECS_DIR.glob("f0_*.yaml")))
    68	    specs.extend(sorted(GOLDEN_SPECS_DIR.glob("f1_*.yaml")))
    69	    return specs
    70	
    71	
    72	def _collect_f0_specs() -> list[Path]:
    73	    """Collect F0 golden specs."""
    74	    return sorted(GOLDEN_SPECS_DIR.glob("f0_*.yaml"))
    75	
    76	
    77	def _collect_f1_specs() -> list[Path]:
    78	    """Collect F1 golden specs."""
    79	    return sorted(GOLDEN_SPECS_DIR.glob("f1_*.yaml"))
    80	
    81	
    82	class _FakeExportRunner:
    83	    """Fake KiCad CLI runner for unit testing export pipeline.
    84	
    85	    Generates deterministic fake export files without requiring KiCad.
    86	    """
    87	
    88	    def __init__(self, *, seed: str = "default", copper_layers: int = 4) -> None:
    89	        self.seed = seed
    90	        self.copper_layers = copper_layers
    91	        self.gerber_calls: list[tuple[Path, Path]] = []
    92	        self.drill_calls: list[tuple[Path, Path]] = []
    93	
    94	    def run_drc(
    95	        self, board_path: Path, report_path: Path
    96	    ) -> subprocess.CompletedProcess[str]:
    97	        """Simulate DRC execution."""
    98	        report_path.parent.mkdir(parents=True, exist_ok=True)
    99	        report_path.write_text(
   100	            json.dumps({"violations": []}), encoding="utf-8"
   101	        )
   102	        return subprocess.CompletedProcess(
   103	            args=["kicad-cli"], returncode=0, stdout="", stderr=""
   104	        )
   105	
   106	    def export_gerbers(
   107	        self, board_path: Path, out_dir: Path
   108	    ) -> subprocess.CompletedProcess[str]:
   109	        """Simulate Gerber export with all required layers."""
   110	        self.gerber_calls.append((board_path, out_dir))
   111	        out_dir.mkdir(parents=True, exist_ok=True)
   112	
   113	        # Get board name prefix from board_path (e.g., "coupon" from "coupon.kicad_pcb")
   114	        board_name = board_path.stem
   115	
   116	        # Generate copper layers based on copper_layers setting
   117	        copper_layer_names = ["F.Cu", "B.Cu"]
   118	        if self.copper_layers >= 4:
   119	            copper_layer_names = ["F.Cu", "In1.Cu", "In2.Cu", "B.Cu"]
   120	        if self.copper_layers >= 6:
   121	            copper_layer_names = ["F.Cu", "In1.Cu", "In2.Cu", "In3.Cu", "In4.Cu", "B.Cu"]
   122	
   123	        # KiCad Gerber extension mapping (industry-standard extensions)
   124	        layer_extension_map = {
   125	            "F.Cu": ".gtl",
   126	            "B.Cu": ".gbl",
   127	            "In1.Cu": ".g1",
   128	            "In2.Cu": ".g2",
   129	            "In3.Cu": ".g3",
   130	            "In4.Cu": ".g4",
   131	            "F.Mask": ".gts",
   132	            "B.Mask": ".gbs",
   133	            "F.SilkS": ".gto",
   134	            "B.SilkS": ".gbo",
   135	            "Edge.Cuts": ".gm1",
   136	        }
   137	
   138	        layers = [
   139	            *[(layer, f"G04 {layer}*") for layer in copper_layer_names],
   140	            ("F.SilkS", "G04 Top Silkscreen*"),
   141	            ("B.SilkS", "G04 Bottom Silkscreen*"),
   142	            ("F.Mask", "G04 Top Soldermask*"),
   143	            ("B.Mask", "G04 Bottom Soldermask*"),
   144	            ("Edge.Cuts", "G04 Board Outline*"),
   145	        ]
   146	
   147	        for layer_name, content_start in layers:
   148	            content_hash = hashlib.sha256(
   149	                f"{self.seed}:{layer_name}".encode()
   150	            ).hexdigest()[:8]
   151	            content = f"{content_start}\nG04 Hash={content_hash}*\nX0Y0D02*\nM02*\n"
   152	            # Convert layer name to KiCad filename format with proper extension
   153	            kicad_layer = layer_name.replace(".", "_")
   154	            extension = layer_extension_map.get(layer_name, ".gbr")
   155	            kicad_filename = f"{board_name}-{kicad_layer}{extension}"
   156	            (out_dir / kicad_filename).write_text(content, encoding="utf-8")
   157	
   158	        return subprocess.CompletedProcess(
   159	            args=["kicad-cli"], returncode=0, stdout="", stderr=""
   160	        )
   161	
   162	    def export_drill(
   163	        self, board_path: Path, out_dir: Path
   164	    ) -> subprocess.CompletedProcess[str]:
   165	        """Simulate drill file export."""
   166	        self.drill_calls.append((board_path, out_dir))
   167	        out_dir.mkdir(parents=True, exist_ok=True)
   168	
   169	        drill_files = [
   170	            ("drill.drl", "M48\n; PTH drill file\nT1C0.3\n%\nT1\nX10Y10\nM30\n"),
   171	            ("drill-NPTH.drl", "M48\n; NPTH drill file\n%\nM30\n"),
   172	        ]
   173	
   174	        for filename, content in drill_files:
   175	            (out_dir / filename).write_text(content, encoding="utf-8")
   176	
   177	        return subprocess.CompletedProcess(
   178	            args=["kicad-cli"], returncode=0, stdout="", stderr=""
   179	        )
   180	
   181	
   182	# ---------------------------------------------------------------------------
   183	# Fixtures
   184	# ---------------------------------------------------------------------------
   185	
   186	
   187	@pytest.fixture(scope="module")
   188	def golden_specs() -> list[Path]:
   189	    """Fixture providing list of golden spec paths."""
   190	    return _collect_golden_specs()
   191	
   192	
   193	# ---------------------------------------------------------------------------
   194	# G4 Gate Tests: Golden Spec Coverage
   195	# ---------------------------------------------------------------------------
   196	
   197	
   198	@pytest.mark.gate_g4
   199	class TestG4GoldenSpecCoverage:
   200	    """Gate G4 tests verifying sufficient golden specs for export testing.
   201	
   202	    Per ECO-M1-ALIGN-0001: "For 10 golden specs per family, CI proves
   203	    export completeness + stable hashes (G4)"
   204	    """
   205	
   206	    def test_minimum_f0_golden_specs_for_export(self) -> None:
   207	        """Verify at least 10 F0 golden specs exist for export testing."""
   208	        specs = _collect_f0_specs()
   209	        assert len(specs) >= 10, (
   210	            f"Expected 10 F0 specs for export gate, found {len(specs)}"
   211	        )
   212	
   213	    def test_minimum_f1_golden_specs_for_export(self) -> None:
   214	        """Verify at least 10 F1 golden specs exist for export testing."""
   215	        specs = _collect_f1_specs()
   216	        assert len(specs) >= 10, (
   217	            f"Expected 10 F1 specs for export gate, found {len(specs)}"
   218	        )
   219	
   220	    def test_total_golden_specs_for_export(self, golden_specs: list[Path]) -> None:
   221	        """Verify at least 20 total golden specs exist for export testing."""
   222	        assert len(golden_specs) >= 20, (
   223	            f"Expected 20 total golden specs for export gate, found {len(golden_specs)}"
   224	        )
   225	
   226	
   227	# ---------------------------------------------------------------------------
   228	# G4 Gate Tests: Layer Set Configuration
   229	# ---------------------------------------------------------------------------
   230	
   231	
   232	@pytest.mark.gate_g4
   233	class TestG4LayerSetConfiguration:
   234	    """Gate G4 tests for layer set configuration per copper count.
   235	
   236	    Per Section 13.5.3: Define and enforce a locked layer set for fab exports.
   237	    """
   238	
   239	    def test_2_layer_copper_set(self) -> None:
   240	        """2-layer boards should have F.Cu and B.Cu."""
   241	        layer_set = get_layer_set_for_copper_count(2)
   242	        assert layer_set.copper == ("F.Cu", "B.Cu")
   243	
   244	    def test_4_layer_copper_set(self) -> None:
   245	        """4-layer boards should have F.Cu, In1.Cu, In2.Cu, B.Cu."""
   246	        layer_set = get_layer_set_for_copper_count(4)
   247	        assert layer_set.copper == ("F.Cu", "In1.Cu", "In2.Cu", "B.Cu")
   248	
   249	    def test_6_layer_copper_set(self) -> None:
   250	        """6-layer boards should have correct copper layers."""
   251	        layer_set = get_layer_set_for_copper_count(6)
   252	        assert len(layer_set.copper) == 6
   253	        assert "In3.Cu" in layer_set.copper
   254	        assert "In4.Cu" in layer_set.copper
   255	
   256	    def test_layer_set_includes_mask_layers(self) -> None:
   257	        """All layer sets should include F.Mask and B.Mask."""
   258	        for copper_count in (2, 4, 6):
   259	            layer_set = get_layer_set_for_copper_count(copper_count)
   260	            assert "F.Mask" in layer_set.mask
   261	            assert "B.Mask" in layer_set.mask
   262	
   263	    def test_layer_set_includes_edge_cuts(self) -> None:
   264	        """All layer sets should include Edge.Cuts."""
   265	        for copper_count in (2, 4, 6):
   266	            layer_set = get_layer_set_for_copper_count(copper_count)
   267	            assert "Edge.Cuts" in layer_set.edge
   268	
   269	    def test_layer_set_optional_silkscreen(self) -> None:
   270	        """Silkscreen layers should be optional."""
   271	        layer_set = get_layer_set_for_copper_count(4)
   272	        assert "F.SilkS" in layer_set.optional
   273	        assert "B.SilkS" in layer_set.optional
   274	
   275	    def test_layer_set_required_layers(self) -> None:
   276	        """Required layers should include copper, mask, and edge cuts."""
   277	        layer_set = get_layer_set_for_copper_count(4)
   278	        required = layer_set.required
   279	        # All copper layers required
   280	        for copper in layer_set.copper:
   281	            assert copper in required, f"{copper} should be required"
   282	        # Mask layers required
   283	        assert "F.Mask" in required
   284	        assert "B.Mask" in required
   285	        # Edge.Cuts required
   286	        assert "Edge.Cuts" in required
   287	
   288	    def test_unsupported_layer_count_raises(self) -> None:
   289	        """Unsupported copper layer counts should raise ValueError."""
   290	        with pytest.raises(ValueError, match="Unsupported copper layer count"):
   291	            get_layer_set_for_copper_count(8)
   292	
   293	
   294	# ---------------------------------------------------------------------------
   295	# G4 Gate Tests: Family-Specific Layer Requirements
   296	# ---------------------------------------------------------------------------
   297	
   298	
   299	@pytest.mark.gate_g4
   300	class TestG4FamilyLayerRequirements:
   301	    """Gate G4 tests for family-specific layer requirements."""
   302	
   303	    def test_f0_family_override_exists(self) -> None:
   304	        """F0 family should have override configuration."""
   305	        override = get_family_override("F0_CAL_THRU_LINE")
   306	        assert override is not None
   307	        assert isinstance(override, FamilyOverride)
   308	
   309	    def test_f1_family_override_exists(self) -> None:
   310	        """F1 family should have override configuration."""
   311	        override = get_family_override("F1_SINGLE_ENDED_VIA")
   312	        assert override is not None
   313	        assert isinstance(override, FamilyOverride)
   314	
   315	    def test_f0_single_layer_sufficient(self) -> None:
   316	        """F0 calibration coupons only need 1 signal layer."""
   317	        override = get_family_override("F0_CAL_THRU_LINE")
   318	        assert override is not None
   319	        assert override.signal_layers_min == 1
   320	        assert override.requires_via_layers is False
   321	
   322	    def test_f1_requires_multiple_layers(self) -> None:
   323	        """F1 via transition coupons require at least 2 layers."""
   324	        override = get_family_override("F1_SINGLE_ENDED_VIA")
   325	        assert override is not None
   326	        assert override.signal_layers_min == 2
   327	        assert override.requires_via_layers is True
   328	
   329	    def test_f1_accepts_4_layers(self) -> None:
   330	        """F1 family should accept 4-layer boards."""
   331	        # Should not raise
   332	        validate_family_layer_requirements(4, "F1_SINGLE_ENDED_VIA")
   333	
   334	    def test_f1_rejects_1_layer(self) -> None:
   335	        """F1 family should reject 1-layer boards."""
   336	        with pytest.raises(ValueError, match="requires at least 2"):
   337	            validate_family_layer_requirements(1, "F1_SINGLE_ENDED_VIA")
   338	
   339	
   340	# ---------------------------------------------------------------------------
   341	# G4 Gate Tests: Layer Extraction from Exports
   342	# ---------------------------------------------------------------------------
   343	
   344	
   345	@pytest.mark.gate_g4
   346	class TestG4LayerExtraction:
   347	    """Gate G4 tests for layer extraction from export paths."""
   348	
   349	    def test_extracts_copper_layers(self) -> None:
   350	        """Should extract copper layer names from Gerber paths.
   351	
   352	        Uses KiCad's standard Gerber extensions (.gtl, .gbl) per layer_sets.json.
   353	        """
   354	        export_paths = [
   355	            "gerbers/board-F_Cu.gtl",
   356	            "gerbers/board-B_Cu.gbl",
   357	        ]
   358	        layers = extract_layers_from_exports(export_paths)
   359	        assert "F.Cu" in layers
   360	        assert "B.Cu" in layers
   361	
   362	    def test_extracts_inner_copper_layers(self) -> None:
   363	        """Should extract inner copper layer names.
   364	
   365	        Uses KiCad's standard inner layer extensions (.g1, .g2).
   366	        """
   367	        export_paths = [
   368	            "gerbers/board-In1_Cu.g1",
   369	            "gerbers/board-In2_Cu.g2",
   370	        ]
   371	        layers = extract_layers_from_exports(export_paths)
   372	        assert "In1.Cu" in layers
   373	        assert "In2.Cu" in layers
   374	
   375	    def test_extracts_mask_layers(self) -> None:
   376	        """Should extract mask layer names.
   377	
   378	        Uses KiCad's standard soldermask extensions (.gts, .gbs).
   379	        """
   380	        export_paths = [
   381	            "gerbers/board-F_Mask.gts",
   382	            "gerbers/board-B_Mask.gbs",
   383	        ]
   384	        layers = extract_layers_from_exports(export_paths)
   385	        assert "F.Mask" in layers
   386	        assert "B.Mask" in layers
   387	
   388	    def test_extracts_edge_cuts(self) -> None:
   389	        """Should extract Edge.Cuts layer.
   390	
   391	        Uses KiCad's standard mechanical layer extension (.gm1).
   392	        """
   393	        export_paths = ["gerbers/board-Edge_Cuts.gm1"]
   394	        layers = extract_layers_from_exports(export_paths)
   395	        assert "Edge.Cuts" in layers
   396	
   397	    def test_ignores_non_gerber_files(self) -> None:
   398	        """Should ignore non-Gerber files."""
   399	        export_paths = [
   400	            "drill/drill.drl",
   401	            "board.kicad_pcb",
   402	        ]
   403	        layers = extract_layers_from_exports(export_paths)
   404	        assert len(layers) == 0
   405	
   406	    def test_respects_gerber_dir_filter(self) -> None:
   407	        """Should only extract from specified gerber directory.
   408	
   409	        Uses KiCad's standard extensions (.gtl, .gbl).
   410	        """
   411	        export_paths = [
   412	            "fab/board-F_Cu.gtl",
   413	            "other/board-B_Cu.gbl",
   414	        ]
   415	        layers = extract_layers_from_exports(export_paths, gerber_dir="fab/")
   416	        assert "F.Cu" in layers
   417	        assert "B.Cu" not in layers
   418	
   419	
   420	# ---------------------------------------------------------------------------
   421	# G4 Gate Tests: Layer Set Validation
   422	# ---------------------------------------------------------------------------
   423	
   424	
   425	@pytest.mark.gate_g4
   426	class TestG4LayerSetValidation:
   427	    """Gate G4 tests for layer set validation logic."""
   428	
   429	    def test_valid_4_layer_set_passes(self) -> None:
   430	        """Complete 4-layer export set should pass validation.
   431	
   432	        Uses KiCad's standard Gerber extensions per layer_sets.json.
   433	        """
   434	        export_paths = [
   435	            "gerbers/board-F_Cu.gtl",
   436	            "gerbers/board-In1_Cu.g1",
   437	            "gerbers/board-In2_Cu.g2",
   438	            "gerbers/board-B_Cu.gbl",
   439	            "gerbers/board-F_Mask.gts",
   440	            "gerbers/board-B_Mask.gbs",
   441	            "gerbers/board-Edge_Cuts.gm1",
   442	        ]
   443	        result = validate_layer_set(
   444	            export_paths=export_paths,
   445	            copper_layers=4,
   446	            family="F1_SINGLE_ENDED_VIA",
   447	            strict=False,
   448	        )
   449	        assert result.passed is True
   450	        assert len(result.missing_layers) == 0
   451	
   452	    def test_missing_inner_layers_fails(self) -> None:
   453	        """Missing inner copper layers should fail validation."""
   454	        export_paths = [
   455	            "gerbers/board-F_Cu.gtl",
   456	            # Missing In1.Cu, In2.Cu
   457	            "gerbers/board-B_Cu.gbl",
   458	            "gerbers/board-F_Mask.gts",
   459	            "gerbers/board-B_Mask.gbs",
   460	            "gerbers/board-Edge_Cuts.gm1",
   461	        ]
   462	        result = validate_layer_set(
   463	            export_paths=export_paths,
   464	            copper_layers=4,
   465	            family="F1_SINGLE_ENDED_VIA",
   466	            strict=False,
   467	        )
   468	        assert result.passed is False
   469	        assert "In1.Cu" in result.missing_layers
   470	        assert "In2.Cu" in result.missing_layers
   471	
   472	    def test_missing_mask_layers_fails(self) -> None:
   473	        """Missing mask layers should fail validation.
   474	
   475	        Uses KiCad's standard Gerber extensions per layer_sets.json.
   476	        """
   477	        export_paths = [
   478	            "gerbers/board-F_Cu.gtl",
   479	            "gerbers/board-B_Cu.gbl",
   480	            # Missing F.Mask, B.Mask
   481	            "gerbers/board-Edge_Cuts.gm1",
   482	        ]
   483	        result = validate_layer_set(
   484	            export_paths=export_paths,
   485	            copper_layers=2,
   486	            family="F0_CAL_THRU_LINE",
   487	            strict=False,
   488	        )
   489	        assert result.passed is False
   490	        assert "F.Mask" in result.missing_layers
   491	        assert "B.Mask" in result.missing_layers
   492	
   493	    def test_missing_edge_cuts_fails(self) -> None:
   494	        """Missing Edge.Cuts should fail validation.
   495	
   496	        Uses KiCad's standard Gerber extensions per layer_sets.json.
   497	        """
   498	        export_paths = [
   499	            "gerbers/board-F_Cu.gtl",
   500	            "gerbers/board-B_Cu.gbl",
   501	            "gerbers/board-F_Mask.gts",
   502	            "gerbers/board-B_Mask.gbs",
   503	            # Missing Edge.Cuts
   504	        ]
   505	        result = validate_layer_set(
   506	            export_paths=export_paths,
   507	            copper_layers=2,
   508	            family="F0_CAL_THRU_LINE",
   509	            strict=False,
   510	        )
   511	        assert result.passed is False
   512	        assert "Edge.Cuts" in result.missing_layers
   513	
   514	    def test_strict_mode_raises_exception(self) -> None:
   515	        """Strict mode should raise LayerSetValidationError on failure."""
   516	        export_paths = ["gerbers/board-F_Cu.gtl"]
   517	        with pytest.raises(LayerSetValidationError) as exc_info:
   518	            validate_layer_set(
   519	                export_paths=export_paths,
   520	                copper_layers=4,
   521	                family="F1_SINGLE_ENDED_VIA",
   522	                strict=True,
   523	            )
   524	        assert exc_info.value.result.passed is False
   525	
   526	    def test_validation_result_has_all_fields(self) -> None:
   527	        """Validation result should have all required fields.
   528	
   529	        Uses KiCad's standard Gerber extensions per layer_sets.json.
   530	        """
   531	        export_paths = [
   532	            "gerbers/board-F_Cu.gtl",
   533	            "gerbers/board-B_Cu.gbl",
   534	            "gerbers/board-F_Mask.gts",
   535	            "gerbers/board-B_Mask.gbs",
   536	            "gerbers/board-Edge_Cuts.gm1",
   537	        ]
   538	        result = validate_layer_set(
   539	            export_paths=export_paths,
   540	            copper_layers=2,
   541	            family="F0_CAL_THRU_LINE",
   542	            strict=False,
   543	        )
   544	        assert hasattr(result, "passed")
   545	        assert hasattr(result, "missing_layers")
   546	        assert hasattr(result, "expected_layers")
   547	        assert hasattr(result, "actual_layers")
   548	        assert hasattr(result, "copper_layer_count")
   549	        assert hasattr(result, "family")
   550	
   551	
   552	# ---------------------------------------------------------------------------
   553	# G4 Gate Tests: Golden Specs Export Configuration
   554	# ---------------------------------------------------------------------------
   555	
   556	
   557	@pytest.mark.gate_g4
   558	class TestG4GoldenSpecsExportConfig:
   559	    """Gate G4 tests verifying golden specs have valid export configuration."""
   560	
   561	    def test_golden_specs_have_export_enabled(
   562	        self, golden_specs: list[Path]
   563	    ) -> None:
   564	        """All golden specs should have export.gerbers.enabled=True."""
   565	        for spec_path in golden_specs:
   566	            spec = load_spec(spec_path)
   567	            assert spec.export.gerbers.enabled is True, (
   568	                f"Golden spec {spec_path.name} must have Gerber export enabled"
   569	            )
   570	
   571	    def test_golden_specs_have_drill_enabled(
   572	        self, golden_specs: list[Path]
   573	    ) -> None:
   574	        """All golden specs should have export.drill.enabled=True."""
   575	        for spec_path in golden_specs:
   576	            spec = load_spec(spec_path)
   577	            assert spec.export.drill.enabled is True, (
   578	                f"Golden spec {spec_path.name} must have drill export enabled"
   579	            )
   580	
   581	    def test_golden_specs_have_valid_copper_count(
   582	        self, golden_specs: list[Path]
   583	    ) -> None:
   584	        """All golden specs should have valid copper layer counts (2, 4, or 6)."""
   585	        for spec_path in golden_specs:
   586	            spec = load_spec(spec_path)
   587	            copper_layers = spec.stackup.copper_layers
   588	            assert copper_layers in (2, 4, 6), (
   589	                f"Golden spec {spec_path.name} has unsupported copper count: {copper_layers}"
   590	            )
   591	
   592	    def test_f0_golden_specs_have_consistent_stackup(self) -> None:
   593	        """F0 golden specs should have consistent stackup configuration."""
   594	        specs = _collect_f0_specs()
   595	        copper_counts = set()
   596	        for spec_path in specs:
   597	            spec = load_spec(spec_path)
   598	            copper_counts.add(spec.stackup.copper_layers)
   599	        # F0 specs may vary, but should be valid
   600	        for count in copper_counts:
   601	            assert count in (2, 4, 6)
   602	
   603	    def test_f1_golden_specs_have_via_support(self) -> None:
   604	        """F1 golden specs should have sufficient layers for vias."""
   605	        specs = _collect_f1_specs()
   606	        for spec_path in specs:
   607	            spec = load_spec(spec_path)
   608	            copper_layers = spec.stackup.copper_layers
   609	            assert copper_layers >= 2, (
   610	                f"F1 spec {spec_path.name} needs 2 layers for via transition"
   611	            )
   612	
   613	
   614	# ---------------------------------------------------------------------------
   615	# G4 Gate Tests: Drill File Requirements
   616	# ---------------------------------------------------------------------------
   617	
   618	
   619	@pytest.mark.gate_g4
   620	class TestG4DrillFileRequirements:
   621	    """Gate G4 tests for drill file requirements."""
   622	
   623	    def test_export_creates_drill_files(self, tmp_path: Path) -> None:
   624	        """Export should create drill files."""
   625	        runner = _FakeExportRunner(seed="test")
   626	        board_path = tmp_path / "test.kicad_pcb"
   627	        out_dir = tmp_path / "drill"
   628	        board_path.write_text("(kicad_pcb)", encoding="utf-8")
   629	
   630	        runner.export_drill(board_path, out_dir)
   631	
   632	        drill_files = list(out_dir.glob("*.drl"))
   633	        assert len(drill_files) >= 1, "Should create at least 1 drill file"
   634	
   635	    def test_pth_drill_file_exists(self, tmp_path: Path) -> None:
   636	        """PTH (Plated Through Hole) drill file should exist."""
   637	        runner = _FakeExportRunner(seed="test")
   638	        board_path = tmp_path / "test.kicad_pcb"
   639	        out_dir = tmp_path / "drill"
   640	        board_path.write_text("(kicad_pcb)", encoding="utf-8")
   641	
   642	        runner.export_drill(board_path, out_dir)
   643	
   644	        # Main drill file is PTH
   645	        pth_files = list(out_dir.glob("drill.drl"))
   646	        assert len(pth_files) >= 1, "PTH drill file should exist"
   647	
   648	    def test_drill_files_are_non_empty(self, tmp_path: Path) -> None:
   649	        """Drill files should have content."""
   650	        runner = _FakeExportRunner(seed="test")
   651	        board_path = tmp_path / "test.kicad_pcb"
   652	        out_dir = tmp_path / "drill"
   653	        board_path.write_text("(kicad_pcb)", encoding="utf-8")
   654	
   655	        runner.export_drill(board_path, out_dir)
   656	
   657	        for drill_file in out_dir.glob("*.drl"):
   658	            assert drill_file.stat().st_size > 0, (
   659	                f"Drill file {drill_file.name} should be non-empty"
   660	            )
   661	
   662	
   663	# ---------------------------------------------------------------------------
   664	# G4 Gate Tests: Golden Specs Export Completeness
   665	# ---------------------------------------------------------------------------
   666	
   667	
   668	@pytest.mark.gate_g4
   669	class TestG4GoldenSpecsExportCompleteness:
   670	    """Gate G4 tests verifying golden specs produce complete exports.
   671	
   672	    Uses fake runners to test export pipeline logic without Docker.
   673	    """
   674	
   675	    @pytest.mark.parametrize(
   676	        "spec_path",
   677	        _collect_golden_specs(),
   678	        ids=lambda p: p.name,
   679	    )
   680	    def test_golden_spec_exports_complete(
   681	        self, spec_path: Path, tmp_path: Path
   682	    ) -> None:
   683	        """Each golden spec should produce complete exports."""
   684	        from formula_foundry.coupongen import build_coupon
   685	
   686	        spec = load_spec(spec_path)
   687	        copper_layers = spec.stackup.copper_layers
   688	        runner = _FakeExportRunner(seed=spec_path.name, copper_layers=copper_layers)
   689	
   690	        result = build_coupon(
   691	            spec,
   692	            out_root=tmp_path,
   693	            mode="docker",
   694	            runner=runner,
   695	            kicad_cli_version="9.0.7",
   696	        )
   697	
   698	        # Verify manifest contains exports
   699	        manifest = json.loads(result.manifest_path.read_text(encoding="utf-8"))
   700	        assert "exports" in manifest, "Manifest must have exports"
   701	
   702	        exports = manifest["exports"]
   703	        assert isinstance(exports, list)
   704	        export_paths = [e["path"] for e in exports]
   705	
   706	        # Verify Gerber exports
   707	        gerber_exports = [p for p in export_paths if "gerbers/" in p]
   708	        assert len(gerber_exports) >= 4, (
   709	            f"Spec {spec_path.name}: Expected 4 Gerber exports, got {len(gerber_exports)}"
   710	        )
   711	
   712	        # Verify drill exports
   713	        drill_exports = [p for p in export_paths if "drill/" in p]
   714	        assert len(drill_exports) >= 1, (
   715	            f"Spec {spec_path.name}: Expected 1 drill export, got {len(drill_exports)}"
   716	        )
   717	
   718	    def test_golden_spec_layer_set_valid(self, tmp_path: Path) -> None:
   719	        """Golden spec exports should have valid layer sets."""
   720	        specs = _collect_golden_specs()
   721	        if not specs:
   722	            pytest.skip("No golden specs available")
   723	
   724	        from formula_foundry.coupongen import build_coupon
   725	
   726	        # Test first spec
   727	        spec_path = specs[0]
   728	        spec = load_spec(spec_path)
   729	        copper_layers = spec.stackup.copper_layers
   730	        family = spec.coupon_family
   731	        runner = _FakeExportRunner(seed="test", copper_layers=copper_layers)
   732	
   733	        result = build_coupon(
   734	            spec,
   735	            out_root=tmp_path,
   736	            mode="docker",
   737	            runner=runner,
   738	            kicad_cli_version="9.0.7",
   739	        )
   740	
   741	        manifest = json.loads(result.manifest_path.read_text(encoding="utf-8"))
   742	        export_paths = [e["path"] for e in manifest["exports"]]
   743	
   744	        # Validate layer set
   745	        validation_result = validate_layer_set(
   746	            export_paths=export_paths,
   747	            copper_layers=copper_layers,
   748	            family=family,
   749	            gerber_dir="gerbers/",
   750	            strict=False,
   751	        )
   752	        assert validation_result.passed, (
   753	            f"Layer validation failed: missing {validation_result.missing_layers}"
   754	        )
   755	
   756	
   757	# ---------------------------------------------------------------------------
   758	# G4 Gate Tests: Gerber Extension Mapping
   759	# ---------------------------------------------------------------------------
   760	
   761	
   762	@pytest.mark.gate_g4
   763	class TestG4GerberExtensionMapping:
   764	    """Gate G4 tests for Gerber file extension mapping."""
   765	
   766	    def test_extension_map_exists(self) -> None:
   767	        """Gerber extension map should be available."""
   768	        ext_map = get_gerber_extension_map()
   769	        assert isinstance(ext_map, dict)
   770	        assert len(ext_map) > 0
   771	
   772	    def test_extension_map_has_copper_layers(self) -> None:
   773	        """Extension map should include copper layers."""
   774	        ext_map = get_gerber_extension_map()
   775	        assert "F.Cu" in ext_map
   776	        assert "B.Cu" in ext_map
   777	
   778	    def test_extension_map_has_mask_layers(self) -> None:
   779	        """Extension map should include mask layers."""
   780	        ext_map = get_gerber_extension_map()
   781	        assert "F.Mask" in ext_map
   782	        assert "B.Mask" in ext_map
   783	
   784	    def test_extension_format(self) -> None:
   785	        """Extensions should use standard KiCad Gerber extensions.
   786	
   787	        KiCad uses industry-standard extensions:
   788	        - .gtl, .gbl for top/bottom copper
   789	        - .g1, .g2, etc. for inner copper layers
   790	        - .gts, .gbs for soldermask
   791	        - .gto, .gbo for silkscreen
   792	        - .gm1 for mechanical/edge cuts
   793	        """
   794	        ext_map = get_gerber_extension_map()
   795	        # Verify extensions are valid KiCad Gerber formats
   796	        valid_extensions = {".gtl", ".gbl", ".g1", ".g2", ".g3", ".g4",
   797	                           ".gts", ".gbs", ".gto", ".gbo", ".gtp", ".gbp", ".gm1"}
   798	        for layer, ext in ext_map.items():
   799	            ext_suffix = "." + ext.split(".")[-1]
   800	            assert ext_suffix in valid_extensions, (
   801	                f"Layer {layer} extension should be a valid KiCad Gerber extension, got {ext}"
   802	            )

================================================================================
FILE: tests/test_m1_export_pipeline.py
================================================================================
     1	"""Tests for the export pipeline module.
     2	
     3	Verifies REQ-M1-019 and REQ-M1-020:
     4	- REQ-M1-019: All output directories must be keyed by design_hash and coupon_id;
     5	              re-running build must not create divergent outputs.
     6	- REQ-M1-020: The build pipeline must implement caching keyed by
     7	              design_hash + toolchain_hash and must be deterministic
     8	              when cache hits occur.
     9	"""
    10	
    11	from __future__ import annotations
    12	
    13	import json
    14	import subprocess
    15	from pathlib import Path
    16	from typing import Any
    17	
    18	from formula_foundry.coupongen.export import (
    19	    CacheKey,
    20	    ExportPipeline,
    21	    ExportResult,
    22	    compute_cache_key,
    23	    is_cache_valid,
    24	    run_export_pipeline,
    25	)
    26	from formula_foundry.coupongen.spec import CouponSpec
    27	
    28	
    29	class _CountingRunner:
    30	    """Test runner that counts calls to each method."""
    31	
    32	    def __init__(self) -> None:
    33	        self.drc_calls = 0
    34	        self.gerber_calls = 0
    35	        self.drill_calls = 0
    36	
    37	    def run_drc(self, board_path: Path, report_path: Path) -> subprocess.CompletedProcess[str]:
    38	        self.drc_calls += 1
    39	        report_path.write_text(json.dumps({"ok": True}), encoding="utf-8")
    40	        return _completed_process()
    41	
    42	    def export_gerbers(self, board_path: Path, out_dir: Path) -> subprocess.CompletedProcess[str]:
    43	        self.gerber_calls += 1
    44	        # Create all required layers for a 4-layer board (per Section 13.5.3)
    45	        # Uses KiCad's standard Gerber extensions
    46	        (out_dir / "board-F_Cu.gtl").write_text("G04 Cached*\nX0Y0D02*\n", encoding="utf-8")
    47	        (out_dir / "board-In1_Cu.g1").write_text("G04 Cached*\nX0Y0D02*\n", encoding="utf-8")
    48	        (out_dir / "board-In2_Cu.g2").write_text("G04 Cached*\nX0Y0D02*\n", encoding="utf-8")
    49	        (out_dir / "board-B_Cu.gbl").write_text("G04 Cached*\nX0Y0D02*\n", encoding="utf-8")
    50	        (out_dir / "board-F_Mask.gts").write_text("G04 Cached*\nX0Y0D02*\n", encoding="utf-8")
    51	        (out_dir / "board-B_Mask.gbs").write_text("G04 Cached*\nX0Y0D02*\n", encoding="utf-8")
    52	        (out_dir / "board-Edge_Cuts.gm1").write_text("G04 Cached*\nX0Y0D02*\n", encoding="utf-8")
    53	        return _completed_process()
    54	
    55	    def export_drill(self, board_path: Path, out_dir: Path) -> subprocess.CompletedProcess[str]:
    56	        self.drill_calls += 1
    57	        (out_dir / "drill.drl").write_text("M48\n", encoding="utf-8")
    58	        return _completed_process()
    59	
    60	
    61	def _completed_process() -> subprocess.CompletedProcess[str]:
    62	    return subprocess.CompletedProcess(args=["kicad-cli"], returncode=0, stdout="", stderr="")
    63	
    64	
    65	def _example_spec_data() -> dict[str, Any]:
    66	    return {
    67	        "schema_version": 1,
    68	        "coupon_family": "F1_SINGLE_ENDED_VIA",
    69	        "units": "nm",
    70	        "toolchain": {
    71	            "kicad": {
    72	                "version": "9.0.7",
    73	                "docker_image": "kicad/kicad:9.0.7@sha256:deadbeef",
    74	            }
    75	        },
    76	        "fab_profile": {"id": "oshpark_4layer", "overrides": {}},
    77	        "stackup": {
    78	            "copper_layers": 4,
    79	            "thicknesses_nm": {
    80	                "L1_to_L2": 180000,
    81	                "L2_to_L3": 800000,
    82	                "L3_to_L4": 180000,
    83	            },
    84	            "materials": {"er": 4.1, "loss_tangent": 0.02},
    85	        },
    86	        "board": {
    87	            "outline": {
    88	                "width_nm": 20000000,
    89	                "length_nm": 80000000,
    90	                "corner_radius_nm": 2000000,
    91	            },
    92	            "origin": {"mode": "EDGE_L_CENTER"},
    93	            "text": {"coupon_id": "${COUPON_ID}", "include_manifest_hash": True},
    94	        },
    95	        "connectors": {
    96	            "left": {
    97	                "footprint": "Coupongen_Connectors:SMA_EndLaunch_Generic",
    98	                "position_nm": [5000000, 0],
    99	                "rotation_deg": 180,
   100	            },
   101	            "right": {
   102	                "footprint": "Coupongen_Connectors:SMA_EndLaunch_Generic",
   103	                "position_nm": [75000000, 0],
   104	                "rotation_deg": 0,
   105	            },
   106	        },
   107	        "transmission_line": {
   108	            "type": "CPWG",
   109	            "layer": "F.Cu",
   110	            "w_nm": 300000,
   111	            "gap_nm": 180000,
   112	            "length_left_nm": 25000000,
   113	            "length_right_nm": 25000000,
   114	            "ground_via_fence": None,
   115	        },
   116	        "discontinuity": {
   117	            "type": "VIA_TRANSITION",
   118	            "signal_via": {
   119	                "drill_nm": 300000,
   120	                "diameter_nm": 650000,
   121	                "pad_diameter_nm": 900000,
   122	            },
   123	            "antipads": {},
   124	            "return_vias": None,
   125	            "plane_cutouts": {},
   126	        },
   127	        "constraints": {
   128	            "mode": "REJECT",
   129	            "drc": {"must_pass": True, "severity": "all"},
   130	            "symmetry": {"enforce": True},
   131	            "allow_unconnected_copper": False,
   132	        },
   133	        "export": {
   134	            "gerbers": {"enabled": True, "format": "gerbers"},
   135	            "drill": {"enabled": True, "format": "excellon"},
   136	            "outputs_dir": "artifacts/",
   137	        },
   138	    }
   139	
   140	
   141	class TestCacheKey:
   142	    """Tests for CacheKey class."""
   143	
   144	    def test_combined_hash_is_deterministic(self) -> None:
   145	        key1 = CacheKey(design_hash="abc123", toolchain_hash="def456")
   146	        key2 = CacheKey(design_hash="abc123", toolchain_hash="def456")
   147	        assert key1.combined_hash == key2.combined_hash
   148	
   149	    def test_combined_hash_differs_for_different_keys(self) -> None:
   150	        key1 = CacheKey(design_hash="abc123", toolchain_hash="def456")
   151	        key2 = CacheKey(design_hash="abc123", toolchain_hash="xyz789")
   152	        assert key1.combined_hash != key2.combined_hash
   153	
   154	    def test_matches_manifest(self) -> None:
   155	        key = CacheKey(design_hash="abc123", toolchain_hash="def456")
   156	        manifest = {"design_hash": "abc123", "toolchain_hash": "def456"}
   157	        assert key.matches(manifest)
   158	
   159	    def test_does_not_match_different_design_hash(self) -> None:
   160	        key = CacheKey(design_hash="abc123", toolchain_hash="def456")
   161	        manifest = {"design_hash": "different", "toolchain_hash": "def456"}
   162	        assert not key.matches(manifest)
   163	
   164	    def test_does_not_match_different_toolchain_hash(self) -> None:
   165	        key = CacheKey(design_hash="abc123", toolchain_hash="def456")
   166	        manifest = {"design_hash": "abc123", "toolchain_hash": "different"}
   167	        assert not key.matches(manifest)
   168	
   169	
   170	class TestExportPipeline:
   171	    """Tests for ExportPipeline class."""
   172	
   173	    def test_run_returns_export_result(self, tmp_path: Path) -> None:
   174	        """Test that running the pipeline returns an ExportResult."""
   175	        runner = _CountingRunner()
   176	        spec = CouponSpec.model_validate(_example_spec_data())
   177	        pipeline = ExportPipeline(out_root=tmp_path, runner=runner, kicad_cli_version="9.0.7")
   178	
   179	        result = pipeline.run(spec)
   180	
   181	        assert isinstance(result, ExportResult)
   182	        assert result.output_dir.exists()
   183	        assert result.manifest_path.exists()
   184	        assert result.cache_hit is False
   185	        assert result.design_hash
   186	        assert result.coupon_id
   187	        assert result.toolchain_hash
   188	
   189	    def test_output_dir_keyed_by_design_hash_req_m1_019(self, tmp_path: Path) -> None:
   190	        """REQ-M1-019: Output directory must be keyed by design_hash and coupon_id."""
   191	        runner = _CountingRunner()
   192	        spec = CouponSpec.model_validate(_example_spec_data())
   193	        pipeline = ExportPipeline(out_root=tmp_path, runner=runner, kicad_cli_version="9.0.7")
   194	
   195	        result = pipeline.run(spec)
   196	
   197	        folder_name = result.output_dir.name
   198	        assert result.design_hash in folder_name
   199	        assert result.coupon_id in folder_name
   200	
   201	    def test_cache_hit_on_second_run_req_m1_020(self, tmp_path: Path) -> None:
   202	        """REQ-M1-020: Cache must hit on second run with same spec."""
   203	        runner = _CountingRunner()
   204	        spec = CouponSpec.model_validate(_example_spec_data())
   205	        pipeline = ExportPipeline(out_root=tmp_path, runner=runner, kicad_cli_version="9.0.7")
   206	
   207	        result_a = pipeline.run(spec)
   208	        assert result_a.cache_hit is False
   209	        assert runner.drc_calls == 1
   210	        assert runner.gerber_calls == 1
   211	        assert runner.drill_calls == 1
   212	
   213	        result_b = pipeline.run(spec)
   214	        assert result_b.cache_hit is True
   215	        assert runner.drc_calls == 1  # No additional calls
   216	        assert runner.gerber_calls == 1
   217	        assert runner.drill_calls == 1
   218	
   219	    def test_cache_miss_on_toolchain_change_req_m1_020(self, tmp_path: Path) -> None:
   220	        """REQ-M1-020: Cache must miss when toolchain changes."""
   221	        runner = _CountingRunner()
   222	        spec = CouponSpec.model_validate(_example_spec_data())
   223	        pipeline = ExportPipeline(out_root=tmp_path, runner=runner, kicad_cli_version="9.0.7")
   224	
   225	        result_a = pipeline.run(spec)
   226	        assert result_a.cache_hit is False
   227	        assert runner.drc_calls == 1
   228	
   229	        # Change toolchain
   230	        modified = _example_spec_data()
   231	        modified["toolchain"]["kicad"]["docker_image"] = "kicad/kicad:9.0.7@sha256:feedbeef"
   232	        spec_modified = CouponSpec.model_validate(modified)
   233	
   234	        result_b = pipeline.run(spec_modified)
   235	        assert result_b.cache_hit is False
   236	        assert runner.drc_calls == 2  # New DRC run
   237	
   238	    def test_deterministic_outputs_req_m1_019(self, tmp_path: Path) -> None:
   239	        """REQ-M1-019: Re-running build must not create divergent outputs."""
   240	        runner = _CountingRunner()
   241	        spec = CouponSpec.model_validate(_example_spec_data())
   242	        pipeline = ExportPipeline(out_root=tmp_path, runner=runner, kicad_cli_version="9.0.7")
   243	
   244	        result_a = pipeline.run(spec)
   245	        result_b = pipeline.run(spec)
   246	
   247	        # Same output directory
   248	        assert result_a.output_dir == result_b.output_dir
   249	        assert result_a.design_hash == result_b.design_hash
   250	        assert result_a.coupon_id == result_b.coupon_id
   251	        assert result_a.toolchain_hash == result_b.toolchain_hash
   252	
   253	
   254	class TestRunExportPipeline:
   255	    """Tests for the convenience function."""
   256	
   257	    def test_functional_interface(self, tmp_path: Path) -> None:
   258	        """Test the functional interface works correctly."""
   259	        runner = _CountingRunner()
   260	        spec = CouponSpec.model_validate(_example_spec_data())
   261	
   262	        result = run_export_pipeline(spec, out_root=tmp_path, runner=runner, kicad_cli_version="9.0.7")
   263	
   264	        assert isinstance(result, ExportResult)
   265	        assert result.output_dir.exists()
   266	
   267	
   268	class TestComputeCacheKey:
   269	    """Tests for compute_cache_key function."""
   270	
   271	    def test_returns_cache_key(self) -> None:
   272	        """Test that compute_cache_key returns a CacheKey."""
   273	        spec = CouponSpec.model_validate(_example_spec_data())
   274	        key = compute_cache_key(spec, kicad_cli_version="9.0.7")
   275	
   276	        assert isinstance(key, CacheKey)
   277	        assert key.design_hash
   278	        assert key.toolchain_hash
   279	
   280	    def test_deterministic(self) -> None:
   281	        """Test that compute_cache_key is deterministic."""
   282	        spec = CouponSpec.model_validate(_example_spec_data())
   283	        key1 = compute_cache_key(spec, kicad_cli_version="9.0.7")
   284	        key2 = compute_cache_key(spec, kicad_cli_version="9.0.7")
   285	
   286	        assert key1.design_hash == key2.design_hash
   287	        assert key1.toolchain_hash == key2.toolchain_hash
   288	
   289	
   290	class TestIsCacheValid:
   291	    """Tests for is_cache_valid function."""
   292	
   293	    def test_returns_false_when_no_cache(self, tmp_path: Path) -> None:
   294	        """Test that is_cache_valid returns False when no cache exists."""
   295	        spec = CouponSpec.model_validate(_example_spec_data())
   296	        assert is_cache_valid(spec, tmp_path, kicad_cli_version="9.0.7") is False
   297	
   298	    def test_returns_true_after_build(self, tmp_path: Path) -> None:
   299	        """Test that is_cache_valid returns True after building."""
   300	        runner = _CountingRunner()
   301	        spec = CouponSpec.model_validate(_example_spec_data())
   302	
   303	        run_export_pipeline(spec, out_root=tmp_path, runner=runner, kicad_cli_version="9.0.7")
   304	        assert is_cache_valid(spec, tmp_path, kicad_cli_version="9.0.7") is True
   305	
   306	    def test_returns_false_after_toolchain_change(self, tmp_path: Path) -> None:
   307	        """Test that is_cache_valid returns False when toolchain changes."""
   308	        runner = _CountingRunner()
   309	        spec = CouponSpec.model_validate(_example_spec_data())
   310	
   311	        run_export_pipeline(spec, out_root=tmp_path, runner=runner, kicad_cli_version="9.0.7")
   312	
   313	        # Change toolchain
   314	        modified = _example_spec_data()
   315	        modified["toolchain"]["kicad"]["docker_image"] = "kicad/kicad:9.0.7@sha256:feedbeef"
   316	        spec_modified = CouponSpec.model_validate(modified)
   317	
   318	        assert is_cache_valid(spec_modified, tmp_path, kicad_cli_version="9.0.7") is False

================================================================================
FILE: tests/golden_specs/f1_via_002.yaml
================================================================================
     1	# Golden spec F1-002: Small via F1 single-ended via transition
     2	# Parameters: 127um trace, 127um gap, via dimensions at KiCad minimum
     3	# NOTE: Via dimensions updated to meet both fab profile and KiCad DRC defaults
     4	#       - KiCad default min_via_drill: 300um (0.3mm)
     5	#       - KiCad default min_via_diameter: 500um (0.5mm)
     6	#       - oshpark_4layer min_via_diameter_nm: 457200nm (458um)
     7	schema_version: 1
     8	coupon_family: F1_SINGLE_ENDED_VIA
     9	units: nm
    10	
    11	toolchain:
    12	  kicad:
    13	    version: "9.0.7"
    14	    docker_image: "kicad/kicad:9.0.7@sha256:0000000000000000000000000000000000000000000000000000000000000001"
    15	
    16	fab_profile:
    17	  id: oshpark_4layer
    18	
    19	stackup:
    20	  copper_layers: 4
    21	  thicknesses_nm:
    22	    L1_to_L2: "170 um"
    23	    L2_to_L3: "1090 um"
    24	    L3_to_L4: "170 um"
    25	  materials:
    26	    er: 3.66
    27	    loss_tangent: 0.0095
    28	
    29	board:
    30	  outline:
    31	    width_nm: "10 mm"
    32	    length_nm: "28 mm"
    33	    corner_radius_nm: "500 um"
    34	  origin:
    35	    mode: EDGE_L_CENTER
    36	  text:
    37	    coupon_id: "F1-VIA-002"
    38	    include_manifest_hash: true
    39	
    40	connectors:
    41	  left:
    42	    footprint: "Coupongen_Connectors:SMA_EndLaunch_Generic"
    43	    position_nm: ["1 mm", "0 nm"]
    44	    rotation_deg: 0
    45	  right:
    46	    footprint: "Coupongen_Connectors:SMA_EndLaunch_Generic"
    47	    position_nm: ["27 mm", "0 nm"]
    48	    rotation_deg: 180
    49	
    50	transmission_line:
    51	  type: CPWG
    52	  layer: F.Cu
    53	  w_nm: "127 um"
    54	  gap_nm: "127 um"
    55	  length_left_nm: "13 mm"
    56	  # CP-2.2: length_right_nm is deprecated for F1 - derived from continuity formula
    57	
    58	discontinuity:
    59	  type: VIA_TRANSITION
    60	  signal_via:
    61	    drill_nm: "300 um"
    62	    diameter_nm: "500 um"
    63	    pad_diameter_nm: "700 um"
    64	  antipads:
    65	    L2:
    66	      shape: CIRCLE
    67	      r_nm: "500 um"
    68	    L3:
    69	      shape: CIRCLE
    70	      r_nm: "500 um"
    71	  return_vias:
    72	    pattern: QUAD
    73	    count: 4
    74	    radius_nm: "1000 um"
    75	    via:
    76	      drill_nm: "300 um"
    77	      diameter_nm: "510 um"
    78	
    79	constraints:
    80	  mode: REJECT
    81	  drc:
    82	    must_pass: true
    83	    severity: all
    84	  symmetry:
    85	    enforce: true
    86	  allow_unconnected_copper: false
    87	
    88	export:
    89	  gerbers:
    90	    enabled: true
    91	    format: gerbers
    92	  drill:
    93	    enabled: true
    94	    format: excellon
    95	  outputs_dir: "./outputs"

================================================================================
FILE: tests/golden_hashes/design_hashes.json
================================================================================
     1	{
     2	  "spec_hashes": {
     3	    "f0_cal_001.json": "1a2d6d9cc68209f5f79a6a6b3786425b76d92c4b7ba30fd0d76b1a7568d87896",
     4	    "f0_cal_001.yaml": "d3758baa41390876d11afd620ca426e812b4552d16b6c2512cb0100c2ff0e41e",
     5	    "f0_cal_002.json": "35b7f472d568a50ef7e053f5a78a67bd7f9ce3ddce2398e426d0db5b2ded2248",
     6	    "f0_cal_002.yaml": "9e123813bfb4c06b90f883b74cdc1c9f40012897143147c86c0a7192baeb1bac",
     7	    "f0_cal_003.json": "c41e18c15ee94ccfbad38a02b7fd98c1edd8c2d41fa143260046d8f4d6a30c72",
     8	    "f0_cal_003.yaml": "a2b73837d713bb253606e6e1bf462081b1af8a2787c916002f0e11131e7866bb",
     9	    "f0_cal_004.json": "bf6a15a5a86618daf1a17a9229efd54e1c82ad12222b15a921a7949356f83ae1",
    10	    "f0_cal_004.yaml": "085897d224a200d3ff3f3c1db42b368c311644b58763ba9a6b81ee8f5777b16c",
    11	    "f0_cal_005.json": "b8806a276ccb927854628ce33ec7196a63616a6d4af5cb03c4ff2cbd17ef48ed",
    12	    "f0_cal_005.yaml": "8bfa7dedfecd07e87a41f0f05d27c4be103ce320041df288a9ce71923dda4228",
    13	    "f0_cal_006.json": "08b826ff0f13f7ac68806106e04a7a84a29b4cad3e436cf4aa53ea7d8773d7dd",
    14	    "f0_cal_006.yaml": "ce0db7e01dc5af4dd55a296e288f6334847c2aedd5de373cf6b62d65fbd5529e",
    15	    "f0_cal_007.json": "567cb63bbcdf1d36dcd696469bbca859003cd7234c60214fa52c7ce4621ff344",
    16	    "f0_cal_007.yaml": "fe6a5f110d6517498ae8bc8adacd2df5459babca9625938928eeb084832fcf48",
    17	    "f0_cal_008.json": "89ec6f6f9ea893a0f7e2334a4ea621601996057374b79d41c9ea064a17f22fd7",
    18	    "f0_cal_008.yaml": "4c73648e4092f3e5f4ba66eed3df8993e9de9e508bd3c8c78b538865962d9d91",
    19	    "f0_cal_009.json": "063d5079334c5093977949f81cedc94c56941e588b8e6e694115d69ac8384897",
    20	    "f0_cal_009.yaml": "c0a1c6c38dbf02310c47412885f5afaa8635eef33abcdf96ce0c1c5e43dd62e3",
    21	    "f0_cal_010.json": "7030135c934bf0ad32f6d2265c158679da944e183add73a3ff2601f1d6349f58",
    22	    "f0_cal_010.yaml": "3c43e2011c8657220901c566ed1d606edc3293144a9cc500d6dc4bf22f104677",
    23	    "f1_via_001.json": "722d1a6c1d4d4679aa1f1884cad5932339339b6bb8e51121a4521f062b8375e0",
    24	    "f1_via_001.yaml": "27c3d2dad723f811182d6c79de1873c804c1bb33e1e365c029875faea3a02eda",
    25	    "f1_via_002.json": "9f344a4998c4c7ecfaaafb1e94694893a8793975720ff3f36d8576189b5cda57",
    26	    "f1_via_002.yaml": "20fbe8becdf0c649dc73551b6caed5a2090384ededdd5ca2003735d4158f3917",
    27	    "f1_via_003.json": "774d07622f2415623367d651ea93e032ce822cba9603a83866be4e7202f2b2e2",
    28	    "f1_via_003.yaml": "a5af29d7b7336885e6ed6f17349a67ea0ad9aca7f180066b26d21252c2d32e42",
    29	    "f1_via_004.json": "f2a6b579ebb635acbb04adc13cfeee9d824cba1030f9bd4bae4dd544cab453bc",
    30	    "f1_via_004.yaml": "ee6d6bf0dc00009c87336f3a9df2c9f98b88e504540a2567edc4687f1afe57c3",
    31	    "f1_via_005.json": "aa6585c2949b9f5b62b3a7d4a53b2c80541f2833ce3b82382e79b53c62b3ded9",
    32	    "f1_via_005.yaml": "03cea53493728ed0d329e0f1f1e6e45b0ba6de67c6c982d64c1a6313cc0c53b2",
    33	    "f1_via_006.json": "16275c0e5318b9fa084d13f61c81faffb6cf3c9537ee149f5e063a5f7843423c",
    34	    "f1_via_006.yaml": "d3826d6d1288819c85d19893751384e3dc6a12b5db5475e621fce1914e3bea10",
    35	    "f1_via_007.json": "12f048b0315e4ea4f5f9098531daad6ce217da369fe494ed350b928ea1fae49a",
    36	    "f1_via_007.yaml": "eb942037e86af5f0088e304ac97ce6a77153e99e9bac1129da2269b62c840040",
    37	    "f1_via_008.json": "ce9d63e3573885150ee6be2f198b6915e5491aa1323ce5ea021057603e5fdd37",
    38	    "f1_via_008.yaml": "a24cb8648262c11f10214f81ffd32872c03afbd504fe1b9bb349292d6e869d40",
    39	    "f1_via_009.json": "189d5351200af90d823deaa71bf7e1b73beae80c53935e6a718c78cfd6de10d3",
    40	    "f1_via_009.yaml": "fa462cf9450c03858569035271baf9df5956f9a1c5dd56f2367c4b9cb7d7207f",
    41	    "f1_via_010.json": "9d1c471405bab5f7ea3a7f28d1d5e7fae1f3aabf48ffa0453fb29335174109fa",
    42	    "f1_via_010.yaml": "64f43b151aa614aeeed43b1c3cef91c0c86b8e2d2cf305a9125569707b85156f"
    43	  }
    44	}

================================================================================
FILE: golden_hashes/design_hashes.json
================================================================================
     1	{
     2	  "spec_hashes": {
     3	    "f0_cal_001.json": "1a2d6d9cc68209f5f79a6a6b3786425b76d92c4b7ba30fd0d76b1a7568d87896",
     4	    "f0_cal_001.yaml": "d3758baa41390876d11afd620ca426e812b4552d16b6c2512cb0100c2ff0e41e",
     5	    "f0_cal_002.json": "35b7f472d568a50ef7e053f5a78a67bd7f9ce3ddce2398e426d0db5b2ded2248",
     6	    "f0_cal_002.yaml": "9e123813bfb4c06b90f883b74cdc1c9f40012897143147c86c0a7192baeb1bac",
     7	    "f0_cal_003.json": "c41e18c15ee94ccfbad38a02b7fd98c1edd8c2d41fa143260046d8f4d6a30c72",
     8	    "f0_cal_003.yaml": "a2b73837d713bb253606e6e1bf462081b1af8a2787c916002f0e11131e7866bb",
     9	    "f0_cal_004.json": "bf6a15a5a86618daf1a17a9229efd54e1c82ad12222b15a921a7949356f83ae1",
    10	    "f0_cal_004.yaml": "085897d224a200d3ff3f3c1db42b368c311644b58763ba9a6b81ee8f5777b16c",
    11	    "f0_cal_005.json": "b8806a276ccb927854628ce33ec7196a63616a6d4af5cb03c4ff2cbd17ef48ed",
    12	    "f0_cal_005.yaml": "8bfa7dedfecd07e87a41f0f05d27c4be103ce320041df288a9ce71923dda4228",
    13	    "f0_cal_006.json": "08b826ff0f13f7ac68806106e04a7a84a29b4cad3e436cf4aa53ea7d8773d7dd",
    14	    "f0_cal_006.yaml": "ce0db7e01dc5af4dd55a296e288f6334847c2aedd5de373cf6b62d65fbd5529e",
    15	    "f0_cal_007.json": "567cb63bbcdf1d36dcd696469bbca859003cd7234c60214fa52c7ce4621ff344",
    16	    "f0_cal_007.yaml": "fe6a5f110d6517498ae8bc8adacd2df5459babca9625938928eeb084832fcf48",
    17	    "f0_cal_008.json": "89ec6f6f9ea893a0f7e2334a4ea621601996057374b79d41c9ea064a17f22fd7",
    18	    "f0_cal_008.yaml": "4c73648e4092f3e5f4ba66eed3df8993e9de9e508bd3c8c78b538865962d9d91",
    19	    "f0_cal_009.json": "063d5079334c5093977949f81cedc94c56941e588b8e6e694115d69ac8384897",
    20	    "f0_cal_009.yaml": "c0a1c6c38dbf02310c47412885f5afaa8635eef33abcdf96ce0c1c5e43dd62e3",
    21	    "f0_cal_010.json": "7030135c934bf0ad32f6d2265c158679da944e183add73a3ff2601f1d6349f58",
    22	    "f0_cal_010.yaml": "3c43e2011c8657220901c566ed1d606edc3293144a9cc500d6dc4bf22f104677",
    23	    "f1_via_001.json": "722d1a6c1d4d4679aa1f1884cad5932339339b6bb8e51121a4521f062b8375e0",
    24	    "f1_via_001.yaml": "27c3d2dad723f811182d6c79de1873c804c1bb33e1e365c029875faea3a02eda",
    25	    "f1_via_002.json": "9f344a4998c4c7ecfaaafb1e94694893a8793975720ff3f36d8576189b5cda57",
    26	    "f1_via_002.yaml": "20fbe8becdf0c649dc73551b6caed5a2090384ededdd5ca2003735d4158f3917",
    27	    "f1_via_003.json": "774d07622f2415623367d651ea93e032ce822cba9603a83866be4e7202f2b2e2",
    28	    "f1_via_003.yaml": "a5af29d7b7336885e6ed6f17349a67ea0ad9aca7f180066b26d21252c2d32e42",
    29	    "f1_via_004.json": "f2a6b579ebb635acbb04adc13cfeee9d824cba1030f9bd4bae4dd544cab453bc",
    30	    "f1_via_004.yaml": "ee6d6bf0dc00009c87336f3a9df2c9f98b88e504540a2567edc4687f1afe57c3",
    31	    "f1_via_005.json": "aa6585c2949b9f5b62b3a7d4a53b2c80541f2833ce3b82382e79b53c62b3ded9",
    32	    "f1_via_005.yaml": "03cea53493728ed0d329e0f1f1e6e45b0ba6de67c6c982d64c1a6313cc0c53b2",
    33	    "f1_via_006.json": "16275c0e5318b9fa084d13f61c81faffb6cf3c9537ee149f5e063a5f7843423c",
    34	    "f1_via_006.yaml": "d3826d6d1288819c85d19893751384e3dc6a12b5db5475e621fce1914e3bea10",
    35	    "f1_via_007.json": "12f048b0315e4ea4f5f9098531daad6ce217da369fe494ed350b928ea1fae49a",
    36	    "f1_via_007.yaml": "eb942037e86af5f0088e304ac97ce6a77153e99e9bac1129da2269b62c840040",
    37	    "f1_via_008.json": "ce9d63e3573885150ee6be2f198b6915e5491aa1323ce5ea021057603e5fdd37",
    38	    "f1_via_008.yaml": "a24cb8648262c11f10214f81ffd32872c03afbd504fe1b9bb349292d6e869d40",
    39	    "f1_via_009.json": "189d5351200af90d823deaa71bf7e1b73beae80c53935e6a718c78cfd6de10d3",
    40	    "f1_via_009.yaml": "fa462cf9450c03858569035271baf9df5956f9a1c5dd56f2367c4b9cb7d7207f",
    41	    "f1_via_010.json": "9d1c471405bab5f7ea3a7f28d1d5e7fae1f3aabf48ffa0453fb29335174109fa",
    42	    "f1_via_010.yaml": "64f43b151aa614aeeed43b1c3cef91c0c86b8e2d2cf305a9125569707b85156f"
    43	  }
    44	}
