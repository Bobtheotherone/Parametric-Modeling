"""Repair task executor for the verify repair loop.

This module provides the callback function that executes repair tasks
generated by the verify repair loop. It ensures:

1. Tasks are executed with proper scope enforcement
2. Only orchestrator-scoped changes are allowed
3. Artifacts are written for all executions
4. The orchestrator does NOT stall after verify failures

CRITICAL: This executor is designed to run INTERNAL orchestrator repairs,
not general project repairs. It enforces strict scope boundaries.
"""

from __future__ import annotations

import json
import subprocess
from collections.abc import Callable
from dataclasses import dataclass, field
from datetime import datetime, timezone
from pathlib import Path
from typing import Any

from bridge.patch_integration import ScopeGuard
from bridge.verify_repair.agent_tasks import RepairTask, build_repair_task_prompt


@dataclass
class RepairExecutionResult:
    """Result of executing repair tasks."""

    success: bool
    tasks_executed: int
    tasks_succeeded: int
    tasks_failed: int
    artifacts_written: list[str] = field(default_factory=list)
    errors: list[str] = field(default_factory=list)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dict for JSON serialization."""
        return {
            "success": self.success,
            "tasks_executed": self.tasks_executed,
            "tasks_succeeded": self.tasks_succeeded,
            "tasks_failed": self.tasks_failed,
            "artifacts_written": self.artifacts_written,
            "errors": self.errors,
        }


class RepairExecutor:
    """Executes repair tasks with scope enforcement.

    This class is responsible for:
    1. Filtering tasks to only those that can be repaired within scope
    2. Executing deterministic repairs (ruff --fix, etc.)
    3. Optionally scheduling agent-driven repairs
    4. Writing execution artifacts
    """

    # Scope for orchestrator-only repairs
    ORCHESTRATOR_ALLOWLIST = (
        "bridge/**",
        "tests/test_orchestrator*.py",
        "tests/test_verify_repair*.py",
    )

    ORCHESTRATOR_DENYLIST = (
        "src/**",
        "tools/**",
        "docs/**",
        "DESIGN_DOCUMENT.md",
        "pyproject.toml",
    )

    def __init__(
        self,
        project_root: Path,
        runs_dir: Path,
        verbose: bool = True,
    ) -> None:
        """Initialize the executor.

        Args:
            project_root: Root of the project
            runs_dir: Directory for writing artifacts
            verbose: Whether to print progress
        """
        self.project_root = project_root
        self.runs_dir = runs_dir
        self.verbose = verbose
        self.scope_guard = ScopeGuard(
            allowlist=self.ORCHESTRATOR_ALLOWLIST,
            denylist=self.ORCHESTRATOR_DENYLIST,
            runs_dir=runs_dir,
        )

    def _log(self, msg: str) -> None:
        """Log a message if verbose."""
        if self.verbose:
            print(f"[repair_executor] {msg}")

    def execute_deterministic_repairs(self) -> RepairExecutionResult:
        """Execute deterministic repairs that don't require agent intervention.

        This includes:
        - ruff --fix for lint errors
        - ruff format for formatting
        - isort for import sorting

        These are safe to run and won't break anything.
        """
        self._log("Running deterministic repairs...")
        artifacts: list[str] = []
        errors: list[str] = []

        # Run ruff --fix
        try:
            self._log("Running ruff check --fix")
            proc = subprocess.run(
                ["ruff", "check", ".", "--fix", "--unsafe-fixes"],
                cwd=str(self.project_root),
                capture_output=True,
                text=True,
                timeout=120,
            )
            if proc.stdout:
                self._log(f"ruff output: {proc.stdout[:500]}")
        except FileNotFoundError:
            errors.append("ruff not found in PATH")
        except subprocess.TimeoutExpired:
            errors.append("ruff timed out after 120s")
        except Exception as e:
            errors.append(f"ruff error: {e}")

        # Run ruff format
        try:
            self._log("Running ruff format")
            proc = subprocess.run(
                ["ruff", "format", "."],
                cwd=str(self.project_root),
                capture_output=True,
                text=True,
                timeout=120,
            )
        except FileNotFoundError:
            pass  # ruff not found already logged
        except subprocess.TimeoutExpired:
            errors.append("ruff format timed out")
        except Exception as e:
            errors.append(f"ruff format error: {e}")

        return RepairExecutionResult(
            success=len(errors) == 0,
            tasks_executed=2,  # ruff check + ruff format
            tasks_succeeded=2 - len(errors),
            tasks_failed=len(errors),
            artifacts_written=artifacts,
            errors=errors,
        )

    def create_agent_task_callback(
        self,
        scheduler_callback: Callable[[list[dict[str, Any]]], bool] | None = None,
    ) -> Callable[[list[RepairTask]], bool]:
        """Create the callback function for run_verify_repair_loop.

        This callback is invoked when the repair loop needs agent-driven repairs.
        It either:
        1. Schedules tasks through the provided scheduler callback, OR
        2. Executes deterministic repairs and writes pending tasks for manual pickup

        Args:
            scheduler_callback: Optional callback to schedule tasks through orchestrator.
                Signature: callback(tasks: list[dict]) -> bool

        Returns:
            A callback function with signature (tasks: list[RepairTask]) -> bool
        """

        def callback(tasks: list[RepairTask]) -> bool:
            """Execute or schedule repair tasks."""
            if not tasks:
                return True

            self._log(f"Processing {len(tasks)} repair task(s)")
            timestamp = datetime.now(timezone.utc).strftime("%Y%m%dT%H%M%SZ")

            # Write repair plan artifact
            plan_path = self.runs_dir / f"repair_plan_{timestamp}.json"
            plan_data = {
                "timestamp": timestamp,
                "tasks": [t.to_dict() for t in tasks],
                "prompts": [build_repair_task_prompt(t) for t in tasks],
            }
            plan_path.write_text(json.dumps(plan_data, indent=2), encoding="utf-8")
            self._log(f"Wrote repair plan: {plan_path}")

            # Filter tasks to those within scope
            orchestrator_tasks = []
            out_of_scope_tasks = []
            for task in tasks:
                # Check if task targets are within scope
                scope_result = self.scope_guard.check_paths(task.target_files)
                if scope_result.allowed or not task.target_files:
                    orchestrator_tasks.append(task)
                else:
                    out_of_scope_tasks.append(task)
                    self._log(f"Task {task.id} targets out-of-scope files, skipping: {[v.path for v in scope_result.violations]}")

            # Run deterministic repairs first
            det_result = self.execute_deterministic_repairs()
            if det_result.errors:
                self._log(f"Deterministic repair errors: {det_result.errors}")

            # If we have a scheduler callback, use it for orchestrator tasks
            if scheduler_callback and orchestrator_tasks:
                self._log(f"Scheduling {len(orchestrator_tasks)} orchestrator repair task(s)")
                task_dicts = [t.to_dict() for t in orchestrator_tasks]
                try:
                    success = scheduler_callback(task_dicts)
                    if success:
                        self._log("Scheduler accepted repair tasks")
                        return True
                    else:
                        self._log("Scheduler rejected repair tasks")
                except Exception as e:
                    self._log(f"Scheduler callback error: {e}")

            # Write out-of-scope tasks for manual review
            if out_of_scope_tasks:
                out_of_scope_path = self.runs_dir / "out_of_scope_repairs.json"
                out_of_scope_data = {
                    "timestamp": timestamp,
                    "reason": "These repair tasks target files outside orchestrator scope",
                    "tasks": [t.to_dict() for t in out_of_scope_tasks],
                    "note": "These require manual intervention or a broader repair scope",
                }
                out_of_scope_path.write_text(json.dumps(out_of_scope_data, indent=2), encoding="utf-8")
                self._log(f"Wrote out-of-scope repairs: {out_of_scope_path}")

            # Return True if deterministic repairs succeeded (partial success is OK)
            return det_result.tasks_succeeded > 0

        return callback


def create_repair_callback(
    project_root: Path,
    runs_dir: Path,
    verbose: bool = True,
    scheduler_callback: Callable[[list[dict[str, Any]]], bool] | None = None,
) -> Callable[[list[Any]], bool]:
    """Factory function to create a repair callback for run_verify_repair_loop.

    This is the primary API for integrating the repair executor with the
    verify repair loop.

    Args:
        project_root: Root of the project
        runs_dir: Directory for artifacts
        verbose: Whether to print progress
        scheduler_callback: Optional callback for scheduling agent tasks

    Returns:
        A callback function suitable for run_verify_repair_loop's agent_task_callback
    """
    executor = RepairExecutor(
        project_root=project_root,
        runs_dir=runs_dir,
        verbose=verbose,
    )
    return executor.create_agent_task_callback(scheduler_callback)
